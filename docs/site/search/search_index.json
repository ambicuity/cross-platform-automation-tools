{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NetTools","text":"<p>Cross-platform CLI automation suite for network and system tools.</p>"},{"location":"#overview","title":"Overview","text":"<p>NetTools is a comprehensive, production-ready CLI automation suite built in Python that provides unified tools for network performance testing, system diagnostics, and connectivity checking across Linux, macOS, and Windows platforms.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Network Performance Testing</li> <li>iperf3 wrapper for bandwidth testing</li> <li>Ping and traceroute functionality</li> <li> <p>Port connectivity checking</p> </li> <li> <p>System Information</p> </li> <li>CPU, memory, and disk usage</li> <li>Network interface details</li> <li> <p>System uptime and platform info</p> </li> <li> <p>Cross-Platform Support</p> </li> <li>Works identically on Linux, macOS, and Windows</li> <li>Platform-aware command execution</li> <li> <p>Consistent output formats</p> </li> <li> <p>Production Quality</p> </li> <li>Comprehensive testing (unit + integration)</li> <li>Type checking with mypy</li> <li>Code formatting with black and ruff</li> <li>CI/CD with GitHub Actions</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install nettools\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code># Test network connectivity\nnettools ping-host google.com --count 5\n\n# Check port connectivity\nnettools check-ports --host localhost --ports 22,80,443\n\n# Get system information\nnettools sysinfo --json\n\n# Run bandwidth test\nnettools iperf3-run --client 192.168.1.5 --duration 10\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation Guide</li> <li>CLI Reference</li> <li>Usage Examples</li> <li>API Documentation</li> <li>Development Guide</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>Optional: iperf3 (for bandwidth testing)</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE file for details.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for details.</p>"},{"location":"installation/","title":"Installation Guide","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>Optional: iperf3 (for bandwidth testing)</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<pre><code>pip install nettools\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/ambicuity/cross-platform-automation-tools.git\ncd cross-platform-automation-tools\npip install -e .\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<pre><code>git clone https://github.com/ambicuity/cross-platform-automation-tools.git\ncd cross-platform-automation-tools\npip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#installing-iperf3-optional","title":"Installing iperf3 (Optional)","text":""},{"location":"installation/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code>sudo apt-get update\nsudo apt-get install iperf3\n</code></pre>"},{"location":"installation/#linux-rhelcentosfedora","title":"Linux (RHEL/CentOS/Fedora)","text":"<pre><code>sudo yum install iperf3\n# or\nsudo dnf install iperf3\n</code></pre>"},{"location":"installation/#macos","title":"macOS","text":"<pre><code>brew install iperf3\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<p>Download from iperf.fr or use Chocolatey: <pre><code>choco install iperf3\n</code></pre></p>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify the installation:</p> <pre><code>nettools --help\n</code></pre> <p>Test basic functionality:</p> <pre><code>nettools sysinfo\nnettools ping-host 8.8.8.8 --count 2\nnettools check-ports 80,443 --host google.com\n</code></pre>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>This page provides the complete API reference for the NetTools CLI module.</p>"},{"location":"api/cli/#nettools.cli.main","title":"<code>nettools.cli.main</code>","text":"<p>Main CLI application entry point.</p>"},{"location":"api/cli/#nettools.cli.main.check_ports","title":"<code>check_ports(host=typer.Option('localhost', '--host', '-h', help='Host to check'), ports=typer.Argument(..., help='Comma-separated list of ports'), timeout=typer.Option(5, '--timeout', '-t', help='Connection timeout'), json_output=typer.Option(False, '--json', help='Output in JSON format'), verbose=typer.Option(False, '--verbose', '-v', help='Verbose output'))</code>","text":"<p>Check if ports are open on a host.</p> Source code in <code>nettools/cli/main.py</code> <pre><code>@app.command(\"check-ports\")\ndef check_ports(\n    host: str = typer.Option(\"localhost\", \"--host\", \"-h\", help=\"Host to check\"),\n    ports: str = typer.Argument(..., help=\"Comma-separated list of ports\"),\n    timeout: int = typer.Option(5, \"--timeout\", \"-t\", help=\"Connection timeout\"),\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output in JSON format\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n) -&gt; None:\n    \"\"\"Check if ports are open on a host.\"\"\"\n    if verbose:\n        logger.setLevel(\"DEBUG\")\n\n    port_list = [int(p.strip()) for p in ports.split(\",\")]\n    checker = PortChecker()\n\n    try:\n        console.print(f\"[green]Checking ports {ports} on {host}[/green]\")\n        result = checker.check_ports(host=host, ports=port_list, timeout=timeout)\n\n        if json_output:\n            console.print(json.dumps(result, indent=2))\n        else:\n            _display_port_result(result)\n\n    except Exception as e:\n        logger.error(f\"Port check error: {e}\")\n        console.print(f\"[red]Error: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/cli/#nettools.cli.main.iperf3_run","title":"<code>iperf3_run(server=typer.Option(False, '--server', '-s', help='Run in server mode'), client=typer.Option(None, '--client', '-c', help='Connect to server at address'), port=typer.Option(5201, '--port', '-p', help='Port to use'), duration=typer.Option(10, '--duration', '-t', help='Test duration in seconds'), json_output=typer.Option(False, '--json', help='Output in JSON format'), verbose=typer.Option(False, '--verbose', '-v', help='Verbose output'))</code>","text":"<p>Run iperf3 bandwidth tests in client or server mode.</p> Source code in <code>nettools/cli/main.py</code> <pre><code>@app.command(\"iperf3-run\")\ndef iperf3_run(\n    server: bool = typer.Option(False, \"--server\", \"-s\", help=\"Run in server mode\"),\n    client: str | None = typer.Option(\n        None, \"--client\", \"-c\", help=\"Connect to server at address\"\n    ),\n    port: int = typer.Option(5201, \"--port\", \"-p\", help=\"Port to use\"),\n    duration: int = typer.Option(\n        10, \"--duration\", \"-t\", help=\"Test duration in seconds\"\n    ),\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output in JSON format\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n) -&gt; None:\n    \"\"\"Run iperf3 bandwidth tests in client or server mode.\"\"\"\n    if verbose:\n        logger.setLevel(\"DEBUG\")\n\n    iperf3 = IPerf3Wrapper()\n\n    try:\n        if server:\n            console.print(f\"[green]Starting iperf3 server on port {port}[/green]\")\n            result = iperf3.run_server(port=port)\n        elif client:\n            console.print(\n                f\"[green]Running iperf3 client test to {client}:{port}[/green]\"\n            )\n            result = iperf3.run_client(host=client, port=port, duration=duration)\n        else:\n            console.print(\"[red]Error: Must specify either --server or --client[/red]\")\n            raise typer.Exit(1)\n\n        if json_output:\n            console.print(json.dumps(result, indent=2))\n        else:\n            _display_iperf3_result(result)\n\n    except Exception as e:\n        logger.error(f\"iperf3 error: {e}\")\n        console.print(f\"[red]Error: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/cli/#nettools.cli.main.ping_host","title":"<code>ping_host(host=typer.Argument(..., help='Host to ping'), count=typer.Option(4, '--count', '-c', help='Number of pings'), timeout=typer.Option(5, '--timeout', '-t', help='Timeout in seconds'), json_output=typer.Option(False, '--json', help='Output in JSON format'), verbose=typer.Option(False, '--verbose', '-v', help='Verbose output'))</code>","text":"<p>Ping a host and show connectivity results.</p> Source code in <code>nettools/cli/main.py</code> <pre><code>@app.command(\"ping-host\")\ndef ping_host(\n    host: str = typer.Argument(..., help=\"Host to ping\"),\n    count: int = typer.Option(4, \"--count\", \"-c\", help=\"Number of pings\"),\n    timeout: int = typer.Option(5, \"--timeout\", \"-t\", help=\"Timeout in seconds\"),\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output in JSON format\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n) -&gt; None:\n    \"\"\"Ping a host and show connectivity results.\"\"\"\n    if verbose:\n        logger.setLevel(\"DEBUG\")\n\n    ping = PingWrapper()\n\n    try:\n        console.print(f\"[green]Pinging {host} with {count} packets[/green]\")\n        result = ping.ping(host=host, count=count, timeout=timeout)\n\n        if json_output:\n            console.print(json.dumps(result, indent=2))\n        else:\n            _display_ping_result(result)\n\n    except Exception as e:\n        logger.error(f\"Ping error: {e}\")\n        console.print(f\"[red]Error: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/cli/#nettools.cli.main.sysinfo","title":"<code>sysinfo(json_output=typer.Option(False, '--json', help='Output in JSON format'), verbose=typer.Option(False, '--verbose', '-v', help='Verbose output'))</code>","text":"<p>Display system information.</p> Source code in <code>nettools/cli/main.py</code> <pre><code>@app.command(\"sysinfo\")\ndef sysinfo(\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output in JSON format\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n) -&gt; None:\n    \"\"\"Display system information.\"\"\"\n    if verbose:\n        logger.setLevel(\"DEBUG\")\n\n    sysinfo_obj = SystemInfo()\n\n    try:\n        result = sysinfo_obj.get_all_info()\n\n        if json_output:\n            console.print(json.dumps(result, indent=2))\n        else:\n            _display_sysinfo_result(result)\n\n    except Exception as e:\n        logger.error(f\"System info error: {e}\")\n        console.print(f\"[red]Error: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"api/core/","title":"Core Reference","text":"<p>This page provides the complete API reference for the NetTools core modules.</p>"},{"location":"api/core/#ping-module","title":"Ping Module","text":""},{"location":"api/core/#nettools.core.ping","title":"<code>nettools.core.ping</code>","text":"<p>Ping wrapper for network connectivity testing.</p>"},{"location":"api/core/#nettools.core.ping.PingWrapper","title":"<code>PingWrapper</code>","text":"<p>Wrapper class for ping operations.</p> Source code in <code>nettools/core/ping.py</code> <pre><code>class PingWrapper:\n    \"\"\"Wrapper class for ping operations.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the ping wrapper.\"\"\"\n        self.logger = get_logger(self.__class__.__name__)\n\n    def ping(\n        self,\n        host: str,\n        count: int = 4,\n        timeout: int = 5,\n        packet_size: int | None = None,\n    ) -&gt; dict:\n        \"\"\"Ping a host and return connectivity results.\n\n        Args:\n            host: Hostname or IP address to ping\n            count: Number of ping packets to send\n            timeout: Timeout in seconds for each ping\n            packet_size: Size of ping packets in bytes (optional)\n\n        Returns:\n            Dictionary with ping results.\n        \"\"\"\n        cmd = self._build_ping_command(host, count, timeout, packet_size)\n\n        self.logger.info(f\"Pinging {host} with {count} packets\")\n        self.logger.debug(f\"Command: {' '.join(cmd)}\")\n\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=timeout * count + 10,  # Add buffer time\n            )\n\n            return self._parse_ping_output(result.stdout, result.stderr, host, count)\n\n        except subprocess.TimeoutExpired:\n            self.logger.error(f\"Ping to {host} timed out\")\n            return {\n                \"host\": host,\n                \"packets_sent\": count,\n                \"packets_received\": 0,\n                \"packet_loss\": 100.0,\n                \"error\": \"Timeout expired\",\n            }\n        except subprocess.SubprocessError as e:\n            self.logger.error(f\"Failed to ping {host}: {e}\")\n            return {\n                \"host\": host,\n                \"packets_sent\": count,\n                \"packets_received\": 0,\n                \"packet_loss\": 100.0,\n                \"error\": str(e),\n            }\n\n    def _build_ping_command(\n        self, host: str, count: int, timeout: int, packet_size: int | None\n    ) -&gt; list[str]:\n        \"\"\"Build the appropriate ping command for the current platform.\n\n        Args:\n            host: Target host\n            count: Number of pings\n            timeout: Timeout per ping\n            packet_size: Packet size in bytes\n\n        Returns:\n            List of command arguments.\n        \"\"\"\n        if is_windows():\n            cmd = [\n                \"ping\",\n                \"-n\",\n                str(count),\n                \"-w\",\n                str(timeout * 1000),\n            ]  # Windows uses milliseconds\n            if packet_size:\n                cmd.extend([\"-l\", str(packet_size)])\n        else:\n            cmd = [\"ping\", \"-c\", str(count), \"-W\", str(timeout)]\n            if packet_size:\n                cmd.extend([\"-s\", str(packet_size)])\n\n        cmd.append(host)\n        return cmd\n\n    def _parse_ping_output(\n        self, stdout: str, stderr: str, host: str, count: int\n    ) -&gt; dict:\n        \"\"\"Parse ping command output into a standardized format.\n\n        Args:\n            stdout: Standard output from ping command\n            stderr: Standard error from ping command\n            host: Target host\n            count: Number of pings sent\n\n        Returns:\n            Parsed ping results.\n        \"\"\"\n        result = {\n            \"host\": host,\n            \"packets_sent\": count,\n            \"packets_received\": 0,\n            \"packet_loss\": 100.0,\n            \"times\": [],\n            \"min_time\": None,\n            \"max_time\": None,\n            \"avg_time\": None,\n            \"raw_output\": stdout,\n        }\n\n        if stderr:\n            result[\"error\"] = stderr.strip()\n            return result\n\n        try:\n            if is_windows():\n                result.update(self._parse_windows_ping(stdout))\n            else:\n                result.update(self._parse_unix_ping(stdout))\n        except Exception as e:\n            self.logger.error(f\"Error parsing ping output: {e}\")\n            result[\"error\"] = f\"Failed to parse output: {e}\"\n\n        return result\n\n    def _parse_windows_ping(self, output: str) -&gt; dict:\n        \"\"\"Parse Windows ping output.\n\n        Args:\n            output: Raw ping output\n\n        Returns:\n            Parsed results dictionary.\n        \"\"\"\n        lines = output.split(\"\\n\")\n        times = []\n        packets_received = 0\n\n        # Extract round-trip times\n        for line in lines:\n            # Look for lines like \"Reply from 8.8.8.8: bytes=32 time=20ms TTL=56\"\n            time_match = re.search(r\"time[&lt;=](\\d+)ms\", line)\n            if time_match:\n                times.append(float(time_match.group(1)))\n                packets_received += 1\n\n        # Extract summary statistics\n        for line in lines:\n            # Look for packet loss info: \"Packets: Sent = 4, Received = 4, Lost = 0 (0% loss)\"\n            loss_match = re.search(r\"Lost = \\d+ \\((\\d+)% loss\\)\", line)\n            if loss_match:\n                packet_loss = float(loss_match.group(1))\n                break\n        else:\n            packet_loss = (len(times) / 4) * 100 if times else 100.0\n\n        result = {\n            \"packets_received\": packets_received,\n            \"packet_loss\": packet_loss,\n            \"times\": times,\n        }\n\n        if times:\n            result.update(\n                {\n                    \"min_time\": min(times),\n                    \"max_time\": max(times),\n                    \"avg_time\": statistics.mean(times),\n                }\n            )\n\n        return result\n\n    def _parse_unix_ping(self, output: str) -&gt; dict:\n        \"\"\"Parse Unix/Linux/macOS ping output.\n\n        Args:\n            output: Raw ping output\n\n        Returns:\n            Parsed results dictionary.\n        \"\"\"\n        lines = output.split(\"\\n\")\n        times = []\n        packets_received = 0\n\n        # Extract round-trip times\n        for line in lines:\n            # Look for lines like \"64 bytes from 8.8.8.8: icmp_seq=1 ttl=56 time=19.6 ms\"\n            time_match = re.search(r\"time=(\\d+\\.?\\d*)\", line)\n            if time_match:\n                times.append(float(time_match.group(1)))\n                packets_received += 1\n\n        # Extract summary statistics\n        for line in lines:\n            # Look for packet loss info: \"4 packets transmitted, 4 received, 0% packet loss\"\n            loss_match = re.search(r\"(\\d+)% packet loss\", line)\n            if loss_match:\n                packet_loss = float(loss_match.group(1))\n                break\n        else:\n            packet_loss = (\n                ((len(times) - packets_received) / len(times)) * 100 if times else 100.0\n            )\n\n        result = {\n            \"packets_received\": packets_received,\n            \"packet_loss\": packet_loss,\n            \"times\": times,\n        }\n\n        if times:\n            result.update(\n                {\n                    \"min_time\": min(times),\n                    \"max_time\": max(times),\n                    \"avg_time\": statistics.mean(times),\n                }\n            )\n\n        return result\n\n    def traceroute(self, host: str, max_hops: int = 30) -&gt; dict:\n        \"\"\"Perform a traceroute to the specified host.\n\n        Args:\n            host: Target host\n            max_hops: Maximum number of hops\n\n        Returns:\n            Dictionary with traceroute results.\n        \"\"\"\n        if is_windows():\n            cmd = [\"tracert\", \"-h\", str(max_hops), host]\n        else:\n            cmd = [\"traceroute\", \"-m\", str(max_hops), host]\n\n        self.logger.info(f\"Running traceroute to {host}\")\n        self.logger.debug(f\"Command: {' '.join(cmd)}\")\n\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=max_hops * 5 + 30,  # Generous timeout\n            )\n\n            return {\n                \"host\": host,\n                \"max_hops\": max_hops,\n                \"success\": result.returncode == 0,\n                \"raw_output\": result.stdout,\n                \"error\": result.stderr if result.stderr else None,\n            }\n\n        except subprocess.TimeoutExpired:\n            self.logger.error(f\"Traceroute to {host} timed out\")\n            return {\n                \"host\": host,\n                \"max_hops\": max_hops,\n                \"success\": False,\n                \"error\": \"Timeout expired\",\n            }\n        except subprocess.SubprocessError as e:\n            self.logger.error(f\"Failed to run traceroute to {host}: {e}\")\n            return {\n                \"host\": host,\n                \"max_hops\": max_hops,\n                \"success\": False,\n                \"error\": str(e),\n            }\n</code></pre>"},{"location":"api/core/#nettools.core.ping.PingWrapper.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the ping wrapper.</p> Source code in <code>nettools/core/ping.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the ping wrapper.\"\"\"\n    self.logger = get_logger(self.__class__.__name__)\n</code></pre>"},{"location":"api/core/#nettools.core.ping.PingWrapper.ping","title":"<code>ping(host, count=4, timeout=5, packet_size=None)</code>","text":"<p>Ping a host and return connectivity results.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname or IP address to ping</p> required <code>count</code> <code>int</code> <p>Number of ping packets to send</p> <code>4</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for each ping</p> <code>5</code> <code>packet_size</code> <code>int | None</code> <p>Size of ping packets in bytes (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with ping results.</p> Source code in <code>nettools/core/ping.py</code> <pre><code>def ping(\n    self,\n    host: str,\n    count: int = 4,\n    timeout: int = 5,\n    packet_size: int | None = None,\n) -&gt; dict:\n    \"\"\"Ping a host and return connectivity results.\n\n    Args:\n        host: Hostname or IP address to ping\n        count: Number of ping packets to send\n        timeout: Timeout in seconds for each ping\n        packet_size: Size of ping packets in bytes (optional)\n\n    Returns:\n        Dictionary with ping results.\n    \"\"\"\n    cmd = self._build_ping_command(host, count, timeout, packet_size)\n\n    self.logger.info(f\"Pinging {host} with {count} packets\")\n    self.logger.debug(f\"Command: {' '.join(cmd)}\")\n\n    try:\n        result = subprocess.run(\n            cmd,\n            capture_output=True,\n            text=True,\n            timeout=timeout * count + 10,  # Add buffer time\n        )\n\n        return self._parse_ping_output(result.stdout, result.stderr, host, count)\n\n    except subprocess.TimeoutExpired:\n        self.logger.error(f\"Ping to {host} timed out\")\n        return {\n            \"host\": host,\n            \"packets_sent\": count,\n            \"packets_received\": 0,\n            \"packet_loss\": 100.0,\n            \"error\": \"Timeout expired\",\n        }\n    except subprocess.SubprocessError as e:\n        self.logger.error(f\"Failed to ping {host}: {e}\")\n        return {\n            \"host\": host,\n            \"packets_sent\": count,\n            \"packets_received\": 0,\n            \"packet_loss\": 100.0,\n            \"error\": str(e),\n        }\n</code></pre>"},{"location":"api/core/#nettools.core.ping.PingWrapper.traceroute","title":"<code>traceroute(host, max_hops=30)</code>","text":"<p>Perform a traceroute to the specified host.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Target host</p> required <code>max_hops</code> <code>int</code> <p>Maximum number of hops</p> <code>30</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with traceroute results.</p> Source code in <code>nettools/core/ping.py</code> <pre><code>def traceroute(self, host: str, max_hops: int = 30) -&gt; dict:\n    \"\"\"Perform a traceroute to the specified host.\n\n    Args:\n        host: Target host\n        max_hops: Maximum number of hops\n\n    Returns:\n        Dictionary with traceroute results.\n    \"\"\"\n    if is_windows():\n        cmd = [\"tracert\", \"-h\", str(max_hops), host]\n    else:\n        cmd = [\"traceroute\", \"-m\", str(max_hops), host]\n\n    self.logger.info(f\"Running traceroute to {host}\")\n    self.logger.debug(f\"Command: {' '.join(cmd)}\")\n\n    try:\n        result = subprocess.run(\n            cmd,\n            capture_output=True,\n            text=True,\n            timeout=max_hops * 5 + 30,  # Generous timeout\n        )\n\n        return {\n            \"host\": host,\n            \"max_hops\": max_hops,\n            \"success\": result.returncode == 0,\n            \"raw_output\": result.stdout,\n            \"error\": result.stderr if result.stderr else None,\n        }\n\n    except subprocess.TimeoutExpired:\n        self.logger.error(f\"Traceroute to {host} timed out\")\n        return {\n            \"host\": host,\n            \"max_hops\": max_hops,\n            \"success\": False,\n            \"error\": \"Timeout expired\",\n        }\n    except subprocess.SubprocessError as e:\n        self.logger.error(f\"Failed to run traceroute to {host}: {e}\")\n        return {\n            \"host\": host,\n            \"max_hops\": max_hops,\n            \"success\": False,\n            \"error\": str(e),\n        }\n</code></pre>"},{"location":"api/core/#ports-module","title":"Ports Module","text":""},{"location":"api/core/#nettools.core.ports","title":"<code>nettools.core.ports</code>","text":"<p>Port checking utilities for network connectivity testing.</p>"},{"location":"api/core/#nettools.core.ports.PortChecker","title":"<code>PortChecker</code>","text":"<p>Utility class for checking port connectivity.</p> Source code in <code>nettools/core/ports.py</code> <pre><code>class PortChecker:\n    \"\"\"Utility class for checking port connectivity.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the port checker.\"\"\"\n        self.logger = get_logger(self.__class__.__name__)\n\n    def check_port(self, host: str, port: int, timeout: int = 5) -&gt; dict:\n        \"\"\"Check if a single port is open on a host.\n\n        Args:\n            host: Hostname or IP address\n            port: Port number to check\n            timeout: Connection timeout in seconds\n\n        Returns:\n            Dictionary with port check result.\n        \"\"\"\n        start_time = time.time()\n\n        try:\n            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n                sock.settimeout(timeout)\n                result = sock.connect_ex((host, port))\n                response_time = time.time() - start_time\n\n                if result == 0:\n                    self.logger.debug(f\"Port {port} is open on {host}\")\n                    return {\n                        \"port\": port,\n                        \"open\": True,\n                        \"response_time\": response_time,\n                        \"error\": None,\n                    }\n                else:\n                    self.logger.debug(f\"Port {port} is closed on {host}\")\n                    return {\n                        \"port\": port,\n                        \"open\": False,\n                        \"response_time\": response_time,\n                        \"error\": f\"Connection failed (error code: {result})\",\n                    }\n\n        except TimeoutError:\n            response_time = time.time() - start_time\n            self.logger.debug(f\"Port {port} check timed out on {host}\")\n            return {\n                \"port\": port,\n                \"open\": False,\n                \"response_time\": response_time,\n                \"error\": \"Connection timeout\",\n            }\n        except socket.gaierror as e:\n            response_time = time.time() - start_time\n            self.logger.error(f\"DNS resolution failed for {host}: {e}\")\n            return {\n                \"port\": port,\n                \"open\": False,\n                \"response_time\": response_time,\n                \"error\": f\"DNS resolution failed: {e}\",\n            }\n        except Exception as e:\n            response_time = time.time() - start_time\n            self.logger.error(f\"Error checking port {port} on {host}: {e}\")\n            return {\n                \"port\": port,\n                \"open\": False,\n                \"response_time\": response_time,\n                \"error\": str(e),\n            }\n\n    def check_ports(\n        self, host: str, ports: list[int], timeout: int = 5, max_threads: int = 50\n    ) -&gt; dict:\n        \"\"\"Check multiple ports on a host concurrently.\n\n        Args:\n            host: Hostname or IP address\n            ports: List of port numbers to check\n            timeout: Connection timeout in seconds for each port\n            max_threads: Maximum number of concurrent threads\n\n        Returns:\n            Dictionary with results for all ports.\n        \"\"\"\n        self.logger.info(f\"Checking {len(ports)} ports on {host}\")\n\n        results = []\n        threads = []\n        semaphore = threading.Semaphore(max_threads)\n\n        def check_port_worker(port: int) -&gt; None:\n            \"\"\"Worker function for threaded port checking.\"\"\"\n            with semaphore:\n                result = self.check_port(host, port, timeout)\n                results.append(result)\n\n        start_time = time.time()\n\n        # Start threads for each port\n        for port in ports:\n            thread = threading.Thread(target=check_port_worker, args=(port,))\n            thread.start()\n            threads.append(thread)\n\n        # Wait for all threads to complete\n        for thread in threads:\n            thread.join()\n\n        total_time = time.time() - start_time\n\n        # Sort results by port number\n        results.sort(key=lambda x: x[\"port\"])\n\n        # Calculate summary statistics\n        open_ports = [r for r in results if r[\"open\"]]\n        closed_ports = [r for r in results if not r[\"open\"]]\n\n        return {\n            \"host\": host,\n            \"total_ports\": len(ports),\n            \"open_ports\": len(open_ports),\n            \"closed_ports\": len(closed_ports),\n            \"scan_time\": total_time,\n            \"ports\": results,\n            \"summary\": {\n                \"open\": [r[\"port\"] for r in open_ports],\n                \"closed\": [r[\"port\"] for r in closed_ports],\n                \"errors\": [\n                    r\n                    for r in results\n                    if r[\"error\"] and \"timeout\" not in r[\"error\"].lower()\n                ],\n            },\n        }\n\n    def scan_common_ports(self, host: str, timeout: int = 5) -&gt; dict:\n        \"\"\"Scan commonly used ports on a host.\n\n        Args:\n            host: Hostname or IP address\n            timeout: Connection timeout in seconds\n\n        Returns:\n            Dictionary with scan results.\n        \"\"\"\n        common_ports = [\n            21,  # FTP\n            22,  # SSH\n            23,  # Telnet\n            25,  # SMTP\n            53,  # DNS\n            80,  # HTTP\n            110,  # POP3\n            143,  # IMAP\n            443,  # HTTPS\n            993,  # IMAPS\n            995,  # POP3S\n            3389,  # RDP\n            5432,  # PostgreSQL\n            3306,  # MySQL\n            1433,  # MSSQL\n            6379,  # Redis\n            27017,  # MongoDB\n            5672,  # RabbitMQ\n            9200,  # Elasticsearch\n            8080,  # HTTP Alt\n        ]\n\n        self.logger.info(f\"Scanning common ports on {host}\")\n        return self.check_ports(host, common_ports, timeout)\n\n    def check_service(self, host: str, service: str, timeout: int = 5) -&gt; dict:\n        \"\"\"Check if a specific service is running by testing its default port.\n\n        Args:\n            host: Hostname or IP address\n            service: Service name (http, https, ssh, ftp, etc.)\n            timeout: Connection timeout in seconds\n\n        Returns:\n            Dictionary with service check result.\n        \"\"\"\n        service_ports = {\n            \"http\": 80,\n            \"https\": 443,\n            \"ssh\": 22,\n            \"ftp\": 21,\n            \"smtp\": 25,\n            \"dns\": 53,\n            \"pop3\": 110,\n            \"imap\": 143,\n            \"telnet\": 23,\n            \"rdp\": 3389,\n            \"mysql\": 3306,\n            \"postgresql\": 5432,\n            \"redis\": 6379,\n            \"mongodb\": 27017,\n            \"rabbitmq\": 5672,\n            \"elasticsearch\": 9200,\n        }\n\n        service_lower = service.lower()\n        if service_lower not in service_ports:\n            return {\n                \"service\": service,\n                \"host\": host,\n                \"error\": f\"Unknown service: {service}. Known services: {', '.join(service_ports.keys())}\",\n            }\n\n        port = service_ports[service_lower]\n        result = self.check_port(host, port, timeout)\n\n        return {\n            \"service\": service,\n            \"host\": host,\n            \"port\": port,\n            \"available\": result[\"open\"],\n            \"response_time\": result[\"response_time\"],\n            \"error\": result[\"error\"],\n        }\n</code></pre>"},{"location":"api/core/#nettools.core.ports.PortChecker.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the port checker.</p> Source code in <code>nettools/core/ports.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the port checker.\"\"\"\n    self.logger = get_logger(self.__class__.__name__)\n</code></pre>"},{"location":"api/core/#nettools.core.ports.PortChecker.check_port","title":"<code>check_port(host, port, timeout=5)</code>","text":"<p>Check if a single port is open on a host.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname or IP address</p> required <code>port</code> <code>int</code> <p>Port number to check</p> required <code>timeout</code> <code>int</code> <p>Connection timeout in seconds</p> <code>5</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with port check result.</p> Source code in <code>nettools/core/ports.py</code> <pre><code>def check_port(self, host: str, port: int, timeout: int = 5) -&gt; dict:\n    \"\"\"Check if a single port is open on a host.\n\n    Args:\n        host: Hostname or IP address\n        port: Port number to check\n        timeout: Connection timeout in seconds\n\n    Returns:\n        Dictionary with port check result.\n    \"\"\"\n    start_time = time.time()\n\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n            sock.settimeout(timeout)\n            result = sock.connect_ex((host, port))\n            response_time = time.time() - start_time\n\n            if result == 0:\n                self.logger.debug(f\"Port {port} is open on {host}\")\n                return {\n                    \"port\": port,\n                    \"open\": True,\n                    \"response_time\": response_time,\n                    \"error\": None,\n                }\n            else:\n                self.logger.debug(f\"Port {port} is closed on {host}\")\n                return {\n                    \"port\": port,\n                    \"open\": False,\n                    \"response_time\": response_time,\n                    \"error\": f\"Connection failed (error code: {result})\",\n                }\n\n    except TimeoutError:\n        response_time = time.time() - start_time\n        self.logger.debug(f\"Port {port} check timed out on {host}\")\n        return {\n            \"port\": port,\n            \"open\": False,\n            \"response_time\": response_time,\n            \"error\": \"Connection timeout\",\n        }\n    except socket.gaierror as e:\n        response_time = time.time() - start_time\n        self.logger.error(f\"DNS resolution failed for {host}: {e}\")\n        return {\n            \"port\": port,\n            \"open\": False,\n            \"response_time\": response_time,\n            \"error\": f\"DNS resolution failed: {e}\",\n        }\n    except Exception as e:\n        response_time = time.time() - start_time\n        self.logger.error(f\"Error checking port {port} on {host}: {e}\")\n        return {\n            \"port\": port,\n            \"open\": False,\n            \"response_time\": response_time,\n            \"error\": str(e),\n        }\n</code></pre>"},{"location":"api/core/#nettools.core.ports.PortChecker.check_ports","title":"<code>check_ports(host, ports, timeout=5, max_threads=50)</code>","text":"<p>Check multiple ports on a host concurrently.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname or IP address</p> required <code>ports</code> <code>list[int]</code> <p>List of port numbers to check</p> required <code>timeout</code> <code>int</code> <p>Connection timeout in seconds for each port</p> <code>5</code> <code>max_threads</code> <code>int</code> <p>Maximum number of concurrent threads</p> <code>50</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with results for all ports.</p> Source code in <code>nettools/core/ports.py</code> <pre><code>def check_ports(\n    self, host: str, ports: list[int], timeout: int = 5, max_threads: int = 50\n) -&gt; dict:\n    \"\"\"Check multiple ports on a host concurrently.\n\n    Args:\n        host: Hostname or IP address\n        ports: List of port numbers to check\n        timeout: Connection timeout in seconds for each port\n        max_threads: Maximum number of concurrent threads\n\n    Returns:\n        Dictionary with results for all ports.\n    \"\"\"\n    self.logger.info(f\"Checking {len(ports)} ports on {host}\")\n\n    results = []\n    threads = []\n    semaphore = threading.Semaphore(max_threads)\n\n    def check_port_worker(port: int) -&gt; None:\n        \"\"\"Worker function for threaded port checking.\"\"\"\n        with semaphore:\n            result = self.check_port(host, port, timeout)\n            results.append(result)\n\n    start_time = time.time()\n\n    # Start threads for each port\n    for port in ports:\n        thread = threading.Thread(target=check_port_worker, args=(port,))\n        thread.start()\n        threads.append(thread)\n\n    # Wait for all threads to complete\n    for thread in threads:\n        thread.join()\n\n    total_time = time.time() - start_time\n\n    # Sort results by port number\n    results.sort(key=lambda x: x[\"port\"])\n\n    # Calculate summary statistics\n    open_ports = [r for r in results if r[\"open\"]]\n    closed_ports = [r for r in results if not r[\"open\"]]\n\n    return {\n        \"host\": host,\n        \"total_ports\": len(ports),\n        \"open_ports\": len(open_ports),\n        \"closed_ports\": len(closed_ports),\n        \"scan_time\": total_time,\n        \"ports\": results,\n        \"summary\": {\n            \"open\": [r[\"port\"] for r in open_ports],\n            \"closed\": [r[\"port\"] for r in closed_ports],\n            \"errors\": [\n                r\n                for r in results\n                if r[\"error\"] and \"timeout\" not in r[\"error\"].lower()\n            ],\n        },\n    }\n</code></pre>"},{"location":"api/core/#nettools.core.ports.PortChecker.check_service","title":"<code>check_service(host, service, timeout=5)</code>","text":"<p>Check if a specific service is running by testing its default port.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname or IP address</p> required <code>service</code> <code>str</code> <p>Service name (http, https, ssh, ftp, etc.)</p> required <code>timeout</code> <code>int</code> <p>Connection timeout in seconds</p> <code>5</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with service check result.</p> Source code in <code>nettools/core/ports.py</code> <pre><code>def check_service(self, host: str, service: str, timeout: int = 5) -&gt; dict:\n    \"\"\"Check if a specific service is running by testing its default port.\n\n    Args:\n        host: Hostname or IP address\n        service: Service name (http, https, ssh, ftp, etc.)\n        timeout: Connection timeout in seconds\n\n    Returns:\n        Dictionary with service check result.\n    \"\"\"\n    service_ports = {\n        \"http\": 80,\n        \"https\": 443,\n        \"ssh\": 22,\n        \"ftp\": 21,\n        \"smtp\": 25,\n        \"dns\": 53,\n        \"pop3\": 110,\n        \"imap\": 143,\n        \"telnet\": 23,\n        \"rdp\": 3389,\n        \"mysql\": 3306,\n        \"postgresql\": 5432,\n        \"redis\": 6379,\n        \"mongodb\": 27017,\n        \"rabbitmq\": 5672,\n        \"elasticsearch\": 9200,\n    }\n\n    service_lower = service.lower()\n    if service_lower not in service_ports:\n        return {\n            \"service\": service,\n            \"host\": host,\n            \"error\": f\"Unknown service: {service}. Known services: {', '.join(service_ports.keys())}\",\n        }\n\n    port = service_ports[service_lower]\n    result = self.check_port(host, port, timeout)\n\n    return {\n        \"service\": service,\n        \"host\": host,\n        \"port\": port,\n        \"available\": result[\"open\"],\n        \"response_time\": result[\"response_time\"],\n        \"error\": result[\"error\"],\n    }\n</code></pre>"},{"location":"api/core/#nettools.core.ports.PortChecker.scan_common_ports","title":"<code>scan_common_ports(host, timeout=5)</code>","text":"<p>Scan commonly used ports on a host.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname or IP address</p> required <code>timeout</code> <code>int</code> <p>Connection timeout in seconds</p> <code>5</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with scan results.</p> Source code in <code>nettools/core/ports.py</code> <pre><code>def scan_common_ports(self, host: str, timeout: int = 5) -&gt; dict:\n    \"\"\"Scan commonly used ports on a host.\n\n    Args:\n        host: Hostname or IP address\n        timeout: Connection timeout in seconds\n\n    Returns:\n        Dictionary with scan results.\n    \"\"\"\n    common_ports = [\n        21,  # FTP\n        22,  # SSH\n        23,  # Telnet\n        25,  # SMTP\n        53,  # DNS\n        80,  # HTTP\n        110,  # POP3\n        143,  # IMAP\n        443,  # HTTPS\n        993,  # IMAPS\n        995,  # POP3S\n        3389,  # RDP\n        5432,  # PostgreSQL\n        3306,  # MySQL\n        1433,  # MSSQL\n        6379,  # Redis\n        27017,  # MongoDB\n        5672,  # RabbitMQ\n        9200,  # Elasticsearch\n        8080,  # HTTP Alt\n    ]\n\n    self.logger.info(f\"Scanning common ports on {host}\")\n    return self.check_ports(host, common_ports, timeout)\n</code></pre>"},{"location":"api/core/#system-info-module","title":"System Info Module","text":""},{"location":"api/core/#nettools.core.sysinfo","title":"<code>nettools.core.sysinfo</code>","text":"<p>System information utilities.</p>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo","title":"<code>SystemInfo</code>","text":"<p>Utility class for gathering system information.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>class SystemInfo:\n    \"\"\"Utility class for gathering system information.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the system info utility.\"\"\"\n        self.logger = get_logger(self.__class__.__name__)\n\n    def get_all_info(self) -&gt; dict:\n        \"\"\"Get comprehensive system information.\n\n        Returns:\n            Dictionary with all system information.\n        \"\"\"\n        self.logger.debug(\"Gathering system information\")\n\n        return {\n            **self.get_platform_info(),\n            \"cpu\": self.get_cpu_info(),\n            \"memory\": self.get_memory_info(),\n            \"disk\": self.get_disk_info(),\n            \"network\": self.get_network_info(),\n            \"uptime\": self.get_uptime(),\n            \"timestamp\": datetime.now().isoformat(),\n        }\n\n    def get_platform_info(self) -&gt; dict:\n        \"\"\"Get platform and OS information.\n\n        Returns:\n            Dictionary with platform details.\n        \"\"\"\n        platform_info = get_platform_info()\n\n        return {\n            \"platform\": platform_info[\"platform\"],\n            \"system\": platform_info[\"system\"],\n            \"architecture\": platform_info[\"architecture\"],\n            \"hostname\": platform_info[\"node\"],\n            \"release\": platform_info[\"release\"],\n            \"version\": platform_info[\"version\"],\n            \"machine\": platform_info[\"machine\"],\n            \"processor\": platform_info[\"processor\"],\n        }\n\n    def get_cpu_info(self) -&gt; dict:\n        \"\"\"Get CPU information and usage statistics.\n\n        Returns:\n            Dictionary with CPU details.\n        \"\"\"\n        try:\n            cpu_info = {\n                \"count\": psutil.cpu_count(logical=True),\n                \"physical_count\": psutil.cpu_count(logical=False),\n                \"usage\": psutil.cpu_percent(interval=1),\n                \"frequency\": None,\n                \"load_avg\": None,\n            }\n\n            # Get CPU frequency if available\n            try:\n                freq = psutil.cpu_freq()\n                if freq:\n                    cpu_info[\"frequency\"] = {\n                        \"current\": freq.current,\n                        \"min\": freq.min,\n                        \"max\": freq.max,\n                    }\n            except (AttributeError, NotImplementedError):\n                self.logger.debug(\"CPU frequency information not available\")\n\n            # Get load average (Unix-like systems only)\n            try:\n                if hasattr(psutil, \"getloadavg\"):\n                    load_avg = psutil.getloadavg()\n                    cpu_info[\"load_avg\"] = {\n                        \"1min\": load_avg[0],\n                        \"5min\": load_avg[1],\n                        \"15min\": load_avg[2],\n                    }\n            except (AttributeError, NotImplementedError):\n                self.logger.debug(\"Load average information not available\")\n\n            return cpu_info\n\n        except Exception as e:\n            self.logger.error(f\"Error getting CPU info: {e}\")\n            return {\"error\": str(e)}\n\n    def get_memory_info(self) -&gt; dict:\n        \"\"\"Get memory usage information.\n\n        Returns:\n            Dictionary with memory details.\n        \"\"\"\n        try:\n            memory = psutil.virtual_memory()\n            swap = psutil.swap_memory()\n\n            return {\n                \"virtual\": {\n                    \"total\": memory.total,\n                    \"available\": memory.available,\n                    \"used\": memory.used,\n                    \"free\": memory.free,\n                    \"percent\": memory.percent,\n                },\n                \"swap\": {\n                    \"total\": swap.total,\n                    \"used\": swap.used,\n                    \"free\": swap.free,\n                    \"percent\": swap.percent,\n                },\n                # Backward compatibility\n                \"total\": memory.total,\n                \"available\": memory.available,\n                \"used\": memory.used,\n                \"percent\": memory.percent,\n            }\n\n        except Exception as e:\n            self.logger.error(f\"Error getting memory info: {e}\")\n            return {\"error\": str(e)}\n\n    def get_disk_info(self) -&gt; dict:\n        \"\"\"Get disk usage information.\n\n        Returns:\n            Dictionary with disk details.\n        \"\"\"\n        try:\n            disk_info = {\"partitions\": []}\n\n            # Get all disk partitions\n            partitions = psutil.disk_partitions()\n\n            for partition in partitions:\n                try:\n                    usage = psutil.disk_usage(partition.mountpoint)\n                    partition_info = {\n                        \"device\": partition.device,\n                        \"mountpoint\": partition.mountpoint,\n                        \"fstype\": partition.fstype,\n                        \"total\": usage.total,\n                        \"used\": usage.used,\n                        \"free\": usage.free,\n                        \"percent\": (\n                            (usage.used / usage.total) * 100 if usage.total &gt; 0 else 0\n                        ),\n                    }\n                    disk_info[\"partitions\"].append(partition_info)\n                except (PermissionError, FileNotFoundError, OSError):\n                    # Skip partitions that can't be accessed\n                    continue\n\n            # Calculate total disk space across all partitions\n            if disk_info[\"partitions\"]:\n                total_space = sum(p[\"total\"] for p in disk_info[\"partitions\"])\n                used_space = sum(p[\"used\"] for p in disk_info[\"partitions\"])\n                free_space = sum(p[\"free\"] for p in disk_info[\"partitions\"])\n\n                disk_info[\"summary\"] = {\n                    \"total\": total_space,\n                    \"used\": used_space,\n                    \"free\": free_space,\n                    \"percent\": (\n                        (used_space / total_space) * 100 if total_space &gt; 0 else 0\n                    ),\n                }\n\n            return disk_info\n\n        except Exception as e:\n            self.logger.error(f\"Error getting disk info: {e}\")\n            return {\"error\": str(e)}\n\n    def get_network_info(self) -&gt; dict:\n        \"\"\"Get network interface information.\n\n        Returns:\n            Dictionary with network details.\n        \"\"\"\n        try:\n            network_info = {\"interfaces\": []}\n\n            # Get network interfaces\n            interfaces = psutil.net_if_addrs()\n            stats = psutil.net_if_stats()\n\n            for interface_name, addresses in interfaces.items():\n                interface_info = {\n                    \"name\": interface_name,\n                    \"addresses\": [],\n                    \"stats\": None,\n                }\n\n                # Get addresses for this interface\n                for addr in addresses:\n                    addr_info = {\n                        \"family\": str(addr.family),\n                        \"address\": addr.address,\n                        \"netmask\": addr.netmask,\n                        \"broadcast\": addr.broadcast,\n                    }\n                    interface_info[\"addresses\"].append(addr_info)\n\n                # Get interface statistics\n                if interface_name in stats:\n                    stat = stats[interface_name]\n                    interface_info[\"stats\"] = {\n                        \"is_up\": stat.isup,\n                        \"duplex\": str(stat.duplex),\n                        \"speed\": stat.speed,\n                        \"mtu\": stat.mtu,\n                    }\n\n                network_info[\"interfaces\"].append(interface_info)\n\n            # Get network I/O statistics\n            try:\n                io_counters = psutil.net_io_counters()\n                network_info[\"io_counters\"] = {\n                    \"bytes_sent\": io_counters.bytes_sent,\n                    \"bytes_recv\": io_counters.bytes_recv,\n                    \"packets_sent\": io_counters.packets_sent,\n                    \"packets_recv\": io_counters.packets_recv,\n                    \"errin\": io_counters.errin,\n                    \"errout\": io_counters.errout,\n                    \"dropin\": io_counters.dropin,\n                    \"dropout\": io_counters.dropout,\n                }\n            except AttributeError:\n                self.logger.debug(\"Network I/O counters not available\")\n\n            return network_info\n\n        except Exception as e:\n            self.logger.error(f\"Error getting network info: {e}\")\n            return {\"error\": str(e)}\n\n    def get_uptime(self) -&gt; str:\n        \"\"\"Get system uptime.\n\n        Returns:\n            String representation of system uptime.\n        \"\"\"\n        try:\n            boot_time = psutil.boot_time()\n            uptime_seconds = time.time() - boot_time\n            uptime_delta = timedelta(seconds=uptime_seconds)\n\n            # Format uptime as \"X days, Y hours, Z minutes\"\n            days = uptime_delta.days\n            hours, remainder = divmod(uptime_delta.seconds, 3600)\n            minutes, _ = divmod(remainder, 60)\n\n            parts = []\n            if days &gt; 0:\n                parts.append(f\"{days} day{'s' if days != 1 else ''}\")\n            if hours &gt; 0:\n                parts.append(f\"{hours} hour{'s' if hours != 1 else ''}\")\n            if minutes &gt; 0:\n                parts.append(f\"{minutes} minute{'s' if minutes != 1 else ''}\")\n\n            return \", \".join(parts) if parts else \"less than a minute\"\n\n        except Exception as e:\n            self.logger.error(f\"Error getting uptime: {e}\")\n            return f\"Error: {e}\"\n\n    def get_processes(self, limit: int = 10) -&gt; dict:\n        \"\"\"Get information about running processes.\n\n        Args:\n            limit: Maximum number of processes to return\n\n        Returns:\n            Dictionary with process information.\n        \"\"\"\n        try:\n            processes = []\n\n            for proc in psutil.process_iter(\n                [\"pid\", \"name\", \"username\", \"cpu_percent\", \"memory_percent\"]\n            ):\n                try:\n                    process_info = proc.info\n                    process_info[\"cpu_percent\"] = proc.cpu_percent()\n                    processes.append(process_info)\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    continue\n\n            # Sort by CPU usage\n            processes.sort(key=lambda x: x.get(\"cpu_percent\", 0), reverse=True)\n\n            return {\n                \"total_processes\": len(processes),\n                \"top_processes\": processes[:limit],\n            }\n\n        except Exception as e:\n            self.logger.error(f\"Error getting process info: {e}\")\n            return {\"error\": str(e)}\n</code></pre>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the system info utility.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the system info utility.\"\"\"\n    self.logger = get_logger(self.__class__.__name__)\n</code></pre>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo.get_all_info","title":"<code>get_all_info()</code>","text":"<p>Get comprehensive system information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with all system information.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>def get_all_info(self) -&gt; dict:\n    \"\"\"Get comprehensive system information.\n\n    Returns:\n        Dictionary with all system information.\n    \"\"\"\n    self.logger.debug(\"Gathering system information\")\n\n    return {\n        **self.get_platform_info(),\n        \"cpu\": self.get_cpu_info(),\n        \"memory\": self.get_memory_info(),\n        \"disk\": self.get_disk_info(),\n        \"network\": self.get_network_info(),\n        \"uptime\": self.get_uptime(),\n        \"timestamp\": datetime.now().isoformat(),\n    }\n</code></pre>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo.get_cpu_info","title":"<code>get_cpu_info()</code>","text":"<p>Get CPU information and usage statistics.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with CPU details.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>def get_cpu_info(self) -&gt; dict:\n    \"\"\"Get CPU information and usage statistics.\n\n    Returns:\n        Dictionary with CPU details.\n    \"\"\"\n    try:\n        cpu_info = {\n            \"count\": psutil.cpu_count(logical=True),\n            \"physical_count\": psutil.cpu_count(logical=False),\n            \"usage\": psutil.cpu_percent(interval=1),\n            \"frequency\": None,\n            \"load_avg\": None,\n        }\n\n        # Get CPU frequency if available\n        try:\n            freq = psutil.cpu_freq()\n            if freq:\n                cpu_info[\"frequency\"] = {\n                    \"current\": freq.current,\n                    \"min\": freq.min,\n                    \"max\": freq.max,\n                }\n        except (AttributeError, NotImplementedError):\n            self.logger.debug(\"CPU frequency information not available\")\n\n        # Get load average (Unix-like systems only)\n        try:\n            if hasattr(psutil, \"getloadavg\"):\n                load_avg = psutil.getloadavg()\n                cpu_info[\"load_avg\"] = {\n                    \"1min\": load_avg[0],\n                    \"5min\": load_avg[1],\n                    \"15min\": load_avg[2],\n                }\n        except (AttributeError, NotImplementedError):\n            self.logger.debug(\"Load average information not available\")\n\n        return cpu_info\n\n    except Exception as e:\n        self.logger.error(f\"Error getting CPU info: {e}\")\n        return {\"error\": str(e)}\n</code></pre>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo.get_disk_info","title":"<code>get_disk_info()</code>","text":"<p>Get disk usage information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with disk details.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>def get_disk_info(self) -&gt; dict:\n    \"\"\"Get disk usage information.\n\n    Returns:\n        Dictionary with disk details.\n    \"\"\"\n    try:\n        disk_info = {\"partitions\": []}\n\n        # Get all disk partitions\n        partitions = psutil.disk_partitions()\n\n        for partition in partitions:\n            try:\n                usage = psutil.disk_usage(partition.mountpoint)\n                partition_info = {\n                    \"device\": partition.device,\n                    \"mountpoint\": partition.mountpoint,\n                    \"fstype\": partition.fstype,\n                    \"total\": usage.total,\n                    \"used\": usage.used,\n                    \"free\": usage.free,\n                    \"percent\": (\n                        (usage.used / usage.total) * 100 if usage.total &gt; 0 else 0\n                    ),\n                }\n                disk_info[\"partitions\"].append(partition_info)\n            except (PermissionError, FileNotFoundError, OSError):\n                # Skip partitions that can't be accessed\n                continue\n\n        # Calculate total disk space across all partitions\n        if disk_info[\"partitions\"]:\n            total_space = sum(p[\"total\"] for p in disk_info[\"partitions\"])\n            used_space = sum(p[\"used\"] for p in disk_info[\"partitions\"])\n            free_space = sum(p[\"free\"] for p in disk_info[\"partitions\"])\n\n            disk_info[\"summary\"] = {\n                \"total\": total_space,\n                \"used\": used_space,\n                \"free\": free_space,\n                \"percent\": (\n                    (used_space / total_space) * 100 if total_space &gt; 0 else 0\n                ),\n            }\n\n        return disk_info\n\n    except Exception as e:\n        self.logger.error(f\"Error getting disk info: {e}\")\n        return {\"error\": str(e)}\n</code></pre>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo.get_memory_info","title":"<code>get_memory_info()</code>","text":"<p>Get memory usage information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with memory details.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>def get_memory_info(self) -&gt; dict:\n    \"\"\"Get memory usage information.\n\n    Returns:\n        Dictionary with memory details.\n    \"\"\"\n    try:\n        memory = psutil.virtual_memory()\n        swap = psutil.swap_memory()\n\n        return {\n            \"virtual\": {\n                \"total\": memory.total,\n                \"available\": memory.available,\n                \"used\": memory.used,\n                \"free\": memory.free,\n                \"percent\": memory.percent,\n            },\n            \"swap\": {\n                \"total\": swap.total,\n                \"used\": swap.used,\n                \"free\": swap.free,\n                \"percent\": swap.percent,\n            },\n            # Backward compatibility\n            \"total\": memory.total,\n            \"available\": memory.available,\n            \"used\": memory.used,\n            \"percent\": memory.percent,\n        }\n\n    except Exception as e:\n        self.logger.error(f\"Error getting memory info: {e}\")\n        return {\"error\": str(e)}\n</code></pre>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo.get_network_info","title":"<code>get_network_info()</code>","text":"<p>Get network interface information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with network details.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>def get_network_info(self) -&gt; dict:\n    \"\"\"Get network interface information.\n\n    Returns:\n        Dictionary with network details.\n    \"\"\"\n    try:\n        network_info = {\"interfaces\": []}\n\n        # Get network interfaces\n        interfaces = psutil.net_if_addrs()\n        stats = psutil.net_if_stats()\n\n        for interface_name, addresses in interfaces.items():\n            interface_info = {\n                \"name\": interface_name,\n                \"addresses\": [],\n                \"stats\": None,\n            }\n\n            # Get addresses for this interface\n            for addr in addresses:\n                addr_info = {\n                    \"family\": str(addr.family),\n                    \"address\": addr.address,\n                    \"netmask\": addr.netmask,\n                    \"broadcast\": addr.broadcast,\n                }\n                interface_info[\"addresses\"].append(addr_info)\n\n            # Get interface statistics\n            if interface_name in stats:\n                stat = stats[interface_name]\n                interface_info[\"stats\"] = {\n                    \"is_up\": stat.isup,\n                    \"duplex\": str(stat.duplex),\n                    \"speed\": stat.speed,\n                    \"mtu\": stat.mtu,\n                }\n\n            network_info[\"interfaces\"].append(interface_info)\n\n        # Get network I/O statistics\n        try:\n            io_counters = psutil.net_io_counters()\n            network_info[\"io_counters\"] = {\n                \"bytes_sent\": io_counters.bytes_sent,\n                \"bytes_recv\": io_counters.bytes_recv,\n                \"packets_sent\": io_counters.packets_sent,\n                \"packets_recv\": io_counters.packets_recv,\n                \"errin\": io_counters.errin,\n                \"errout\": io_counters.errout,\n                \"dropin\": io_counters.dropin,\n                \"dropout\": io_counters.dropout,\n            }\n        except AttributeError:\n            self.logger.debug(\"Network I/O counters not available\")\n\n        return network_info\n\n    except Exception as e:\n        self.logger.error(f\"Error getting network info: {e}\")\n        return {\"error\": str(e)}\n</code></pre>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo.get_platform_info","title":"<code>get_platform_info()</code>","text":"<p>Get platform and OS information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with platform details.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>def get_platform_info(self) -&gt; dict:\n    \"\"\"Get platform and OS information.\n\n    Returns:\n        Dictionary with platform details.\n    \"\"\"\n    platform_info = get_platform_info()\n\n    return {\n        \"platform\": platform_info[\"platform\"],\n        \"system\": platform_info[\"system\"],\n        \"architecture\": platform_info[\"architecture\"],\n        \"hostname\": platform_info[\"node\"],\n        \"release\": platform_info[\"release\"],\n        \"version\": platform_info[\"version\"],\n        \"machine\": platform_info[\"machine\"],\n        \"processor\": platform_info[\"processor\"],\n    }\n</code></pre>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo.get_processes","title":"<code>get_processes(limit=10)</code>","text":"<p>Get information about running processes.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of processes to return</p> <code>10</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with process information.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>def get_processes(self, limit: int = 10) -&gt; dict:\n    \"\"\"Get information about running processes.\n\n    Args:\n        limit: Maximum number of processes to return\n\n    Returns:\n        Dictionary with process information.\n    \"\"\"\n    try:\n        processes = []\n\n        for proc in psutil.process_iter(\n            [\"pid\", \"name\", \"username\", \"cpu_percent\", \"memory_percent\"]\n        ):\n            try:\n                process_info = proc.info\n                process_info[\"cpu_percent\"] = proc.cpu_percent()\n                processes.append(process_info)\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                continue\n\n        # Sort by CPU usage\n        processes.sort(key=lambda x: x.get(\"cpu_percent\", 0), reverse=True)\n\n        return {\n            \"total_processes\": len(processes),\n            \"top_processes\": processes[:limit],\n        }\n\n    except Exception as e:\n        self.logger.error(f\"Error getting process info: {e}\")\n        return {\"error\": str(e)}\n</code></pre>"},{"location":"api/core/#nettools.core.sysinfo.SystemInfo.get_uptime","title":"<code>get_uptime()</code>","text":"<p>Get system uptime.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of system uptime.</p> Source code in <code>nettools/core/sysinfo.py</code> <pre><code>def get_uptime(self) -&gt; str:\n    \"\"\"Get system uptime.\n\n    Returns:\n        String representation of system uptime.\n    \"\"\"\n    try:\n        boot_time = psutil.boot_time()\n        uptime_seconds = time.time() - boot_time\n        uptime_delta = timedelta(seconds=uptime_seconds)\n\n        # Format uptime as \"X days, Y hours, Z minutes\"\n        days = uptime_delta.days\n        hours, remainder = divmod(uptime_delta.seconds, 3600)\n        minutes, _ = divmod(remainder, 60)\n\n        parts = []\n        if days &gt; 0:\n            parts.append(f\"{days} day{'s' if days != 1 else ''}\")\n        if hours &gt; 0:\n            parts.append(f\"{hours} hour{'s' if hours != 1 else ''}\")\n        if minutes &gt; 0:\n            parts.append(f\"{minutes} minute{'s' if minutes != 1 else ''}\")\n\n        return \", \".join(parts) if parts else \"less than a minute\"\n\n    except Exception as e:\n        self.logger.error(f\"Error getting uptime: {e}\")\n        return f\"Error: {e}\"\n</code></pre>"},{"location":"api/core/#iperf3-module","title":"iPerf3 Module","text":""},{"location":"api/core/#nettools.core.iperf3","title":"<code>nettools.core.iperf3</code>","text":"<p>iPerf3 wrapper for bandwidth testing.</p>"},{"location":"api/core/#nettools.core.iperf3.IPerf3Wrapper","title":"<code>IPerf3Wrapper</code>","text":"<p>Wrapper class for iperf3 operations.</p> Source code in <code>nettools/core/iperf3.py</code> <pre><code>class IPerf3Wrapper:\n    \"\"\"Wrapper class for iperf3 operations.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the iperf3 wrapper.\"\"\"\n        self.logger = get_logger(self.__class__.__name__)\n        self._check_iperf3_availability()\n\n    def _check_iperf3_availability(self) -&gt; None:\n        \"\"\"Check if iperf3 is available on the system.\"\"\"\n        try:\n            result = subprocess.run(\n                [\"iperf3\", \"--version\"], capture_output=True, text=True, timeout=10\n            )\n            if result.returncode != 0:\n                raise FileNotFoundError(\"iperf3 not found or not executable\")\n            self.logger.debug(\"iperf3 found and available\")\n        except (FileNotFoundError, subprocess.TimeoutExpired):\n            raise RuntimeError(\n                \"iperf3 is not installed or not available in PATH. \"\n                \"Please install iperf3 to use this functionality.\"\n            )\n\n    def run_server(self, port: int = 5201, bind_address: str | None = None) -&gt; dict:\n        \"\"\"Run iperf3 in server mode.\n\n        Args:\n            port: Port to listen on (default: 5201)\n            bind_address: Address to bind to (default: all interfaces)\n\n        Returns:\n            Dictionary with server information.\n        \"\"\"\n        cmd = [\"iperf3\", \"--server\", \"--port\", str(port)]\n\n        if bind_address:\n            cmd.extend([\"--bind\", bind_address])\n\n        self.logger.info(f\"Starting iperf3 server on port {port}\")\n        self.logger.debug(f\"Command: {' '.join(cmd)}\")\n\n        try:\n            # For server mode, we need to handle this differently\n            # as it runs indefinitely until stopped\n            process = subprocess.Popen(\n                cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True\n            )\n\n            return {\n                \"mode\": \"server\",\n                \"port\": port,\n                \"bind_address\": bind_address,\n                \"status\": \"running\",\n                \"pid\": process.pid,\n            }\n\n        except subprocess.SubprocessError as e:\n            self.logger.error(f\"Failed to start iperf3 server: {e}\")\n            raise RuntimeError(f\"Failed to start iperf3 server: {e}\")\n\n    def run_client(\n        self,\n        host: str,\n        port: int = 5201,\n        duration: int = 10,\n        parallel: int = 1,\n        reverse: bool = False,\n    ) -&gt; dict:\n        \"\"\"Run iperf3 in client mode.\n\n        Args:\n            host: Server hostname or IP address\n            port: Server port (default: 5201)\n            duration: Test duration in seconds (default: 10)\n            parallel: Number of parallel streams (default: 1)\n            reverse: Run in reverse mode (server sends) (default: False)\n\n        Returns:\n            Dictionary with test results.\n        \"\"\"\n        cmd = [\n            \"iperf3\",\n            \"--client\",\n            host,\n            \"--port\",\n            str(port),\n            \"--time\",\n            str(duration),\n            \"--parallel\",\n            str(parallel),\n            \"--json\",\n        ]\n\n        if reverse:\n            cmd.append(\"--reverse\")\n\n        self.logger.info(f\"Running iperf3 client test to {host}:{port}\")\n        self.logger.debug(f\"Command: {' '.join(cmd)}\")\n\n        try:\n            result = subprocess.run(\n                cmd,\n                capture_output=True,\n                text=True,\n                timeout=duration + 30,  # Add buffer time\n            )\n\n            if result.returncode != 0:\n                error_msg = result.stderr.strip() or \"Unknown iperf3 error\"\n                raise RuntimeError(f\"iperf3 client failed: {error_msg}\")\n\n            # Parse JSON output\n            try:\n                raw_result = json.loads(result.stdout)\n                return self._parse_client_result(raw_result)\n            except json.JSONDecodeError as e:\n                self.logger.error(f\"Failed to parse iperf3 JSON output: {e}\")\n                # Fallback to text parsing\n                return self._parse_text_output(result.stdout)\n\n        except subprocess.TimeoutExpired:\n            self.logger.error(\"iperf3 client test timed out\")\n            raise RuntimeError(\"iperf3 client test timed out\")\n        except subprocess.SubprocessError as e:\n            self.logger.error(f\"Failed to run iperf3 client: {e}\")\n            raise RuntimeError(f\"Failed to run iperf3 client: {e}\")\n\n    def _parse_client_result(self, raw_result: dict) -&gt; dict:\n        \"\"\"Parse iperf3 JSON output into a standardized format.\n\n        Args:\n            raw_result: Raw JSON result from iperf3\n\n        Returns:\n            Parsed result dictionary.\n        \"\"\"\n        try:\n            end = raw_result.get(\"end\", {})\n            sum_sent = end.get(\"sum_sent\", {})\n            sum_received = end.get(\"sum_received\", {})\n\n            # Use received data if available (for normal mode)\n            # Use sent data if in reverse mode or if received is not available\n            primary_data = sum_received if sum_received else sum_sent\n\n            return {\n                \"mode\": \"client\",\n                \"host\": raw_result.get(\"start\", {})\n                .get(\"connecting_to\", {})\n                .get(\"host\"),\n                \"port\": raw_result.get(\"start\", {})\n                .get(\"connecting_to\", {})\n                .get(\"port\"),\n                \"duration\": primary_data.get(\"seconds\", 0),\n                \"bytes_transferred\": primary_data.get(\"bytes\", 0),\n                \"bits_per_second\": primary_data.get(\"bits_per_second\", 0),\n                \"bandwidth\": primary_data.get(\"bits_per_second\", 0)\n                / 1_000_000,  # Convert to Mbits/sec\n                \"retransmits\": sum_sent.get(\"retransmits\", 0),\n                \"cpu_utilization\": {\n                    \"local\": end.get(\"cpu_utilization_percent\", {}).get(\n                        \"host_total\", 0\n                    ),\n                    \"remote\": end.get(\"cpu_utilization_percent\", {}).get(\n                        \"remote_total\", 0\n                    ),\n                },\n                \"raw_result\": raw_result,\n            }\n        except (KeyError, TypeError) as e:\n            self.logger.error(f\"Error parsing iperf3 result: {e}\")\n            return {\n                \"mode\": \"client\",\n                \"error\": f\"Failed to parse result: {e}\",\n                \"raw_result\": raw_result,\n            }\n\n    def _parse_text_output(self, output: str) -&gt; dict:\n        \"\"\"Parse text output as fallback when JSON parsing fails.\n\n        Args:\n            output: Raw text output from iperf3\n\n        Returns:\n            Basic result dictionary.\n        \"\"\"\n        # This is a simple fallback parser for text output\n        lines = output.split(\"\\n\")\n        result = {\n            \"mode\": \"client\",\n            \"error\": \"JSON parsing failed, using text parsing\",\n            \"raw_output\": output,\n        }\n\n        # Try to extract basic bandwidth information\n        for line in lines:\n            if \"Mbits/sec\" in line and \"sender\" in line:\n                try:\n                    parts = line.split()\n                    for i, part in enumerate(parts):\n                        if \"Mbits/sec\" in part and i &gt; 0:\n                            result[\"bandwidth\"] = float(parts[i - 1])\n                            break\n                except (ValueError, IndexError):\n                    pass\n\n        return result\n</code></pre>"},{"location":"api/core/#nettools.core.iperf3.IPerf3Wrapper.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the iperf3 wrapper.</p> Source code in <code>nettools/core/iperf3.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the iperf3 wrapper.\"\"\"\n    self.logger = get_logger(self.__class__.__name__)\n    self._check_iperf3_availability()\n</code></pre>"},{"location":"api/core/#nettools.core.iperf3.IPerf3Wrapper.run_client","title":"<code>run_client(host, port=5201, duration=10, parallel=1, reverse=False)</code>","text":"<p>Run iperf3 in client mode.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Server hostname or IP address</p> required <code>port</code> <code>int</code> <p>Server port (default: 5201)</p> <code>5201</code> <code>duration</code> <code>int</code> <p>Test duration in seconds (default: 10)</p> <code>10</code> <code>parallel</code> <code>int</code> <p>Number of parallel streams (default: 1)</p> <code>1</code> <code>reverse</code> <code>bool</code> <p>Run in reverse mode (server sends) (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with test results.</p> Source code in <code>nettools/core/iperf3.py</code> <pre><code>def run_client(\n    self,\n    host: str,\n    port: int = 5201,\n    duration: int = 10,\n    parallel: int = 1,\n    reverse: bool = False,\n) -&gt; dict:\n    \"\"\"Run iperf3 in client mode.\n\n    Args:\n        host: Server hostname or IP address\n        port: Server port (default: 5201)\n        duration: Test duration in seconds (default: 10)\n        parallel: Number of parallel streams (default: 1)\n        reverse: Run in reverse mode (server sends) (default: False)\n\n    Returns:\n        Dictionary with test results.\n    \"\"\"\n    cmd = [\n        \"iperf3\",\n        \"--client\",\n        host,\n        \"--port\",\n        str(port),\n        \"--time\",\n        str(duration),\n        \"--parallel\",\n        str(parallel),\n        \"--json\",\n    ]\n\n    if reverse:\n        cmd.append(\"--reverse\")\n\n    self.logger.info(f\"Running iperf3 client test to {host}:{port}\")\n    self.logger.debug(f\"Command: {' '.join(cmd)}\")\n\n    try:\n        result = subprocess.run(\n            cmd,\n            capture_output=True,\n            text=True,\n            timeout=duration + 30,  # Add buffer time\n        )\n\n        if result.returncode != 0:\n            error_msg = result.stderr.strip() or \"Unknown iperf3 error\"\n            raise RuntimeError(f\"iperf3 client failed: {error_msg}\")\n\n        # Parse JSON output\n        try:\n            raw_result = json.loads(result.stdout)\n            return self._parse_client_result(raw_result)\n        except json.JSONDecodeError as e:\n            self.logger.error(f\"Failed to parse iperf3 JSON output: {e}\")\n            # Fallback to text parsing\n            return self._parse_text_output(result.stdout)\n\n    except subprocess.TimeoutExpired:\n        self.logger.error(\"iperf3 client test timed out\")\n        raise RuntimeError(\"iperf3 client test timed out\")\n    except subprocess.SubprocessError as e:\n        self.logger.error(f\"Failed to run iperf3 client: {e}\")\n        raise RuntimeError(f\"Failed to run iperf3 client: {e}\")\n</code></pre>"},{"location":"api/core/#nettools.core.iperf3.IPerf3Wrapper.run_server","title":"<code>run_server(port=5201, bind_address=None)</code>","text":"<p>Run iperf3 in server mode.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to listen on (default: 5201)</p> <code>5201</code> <code>bind_address</code> <code>str | None</code> <p>Address to bind to (default: all interfaces)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with server information.</p> Source code in <code>nettools/core/iperf3.py</code> <pre><code>def run_server(self, port: int = 5201, bind_address: str | None = None) -&gt; dict:\n    \"\"\"Run iperf3 in server mode.\n\n    Args:\n        port: Port to listen on (default: 5201)\n        bind_address: Address to bind to (default: all interfaces)\n\n    Returns:\n        Dictionary with server information.\n    \"\"\"\n    cmd = [\"iperf3\", \"--server\", \"--port\", str(port)]\n\n    if bind_address:\n        cmd.extend([\"--bind\", bind_address])\n\n    self.logger.info(f\"Starting iperf3 server on port {port}\")\n    self.logger.debug(f\"Command: {' '.join(cmd)}\")\n\n    try:\n        # For server mode, we need to handle this differently\n        # as it runs indefinitely until stopped\n        process = subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True\n        )\n\n        return {\n            \"mode\": \"server\",\n            \"port\": port,\n            \"bind_address\": bind_address,\n            \"status\": \"running\",\n            \"pid\": process.pid,\n        }\n\n    except subprocess.SubprocessError as e:\n        self.logger.error(f\"Failed to start iperf3 server: {e}\")\n        raise RuntimeError(f\"Failed to start iperf3 server: {e}\")\n</code></pre>"},{"location":"api/utils/","title":"Utilities Reference","text":"<p>This page provides the complete API reference for the NetTools utility modules.</p>"},{"location":"api/utils/#logger","title":"Logger","text":""},{"location":"api/utils/#nettools.utils.logger","title":"<code>nettools.utils.logger</code>","text":"<p>Logging utilities for nettools.</p>"},{"location":"api/utils/#nettools.utils.logger.get_logger","title":"<code>get_logger(name=None)</code>","text":"<p>Get a configured logger instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Logger name. If None, uses 'nettools' as default.</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>Configured logger instance.</p> Source code in <code>nettools/utils/logger.py</code> <pre><code>def get_logger(name: str | None = None) -&gt; logging.Logger:\n    \"\"\"Get a configured logger instance.\n\n    Args:\n        name: Logger name. If None, uses 'nettools' as default.\n\n    Returns:\n        Configured logger instance.\n    \"\"\"\n    logger_name = name or \"nettools\"\n    logger = logging.getLogger(logger_name)\n\n    if not logger.handlers:\n        # Create console handler\n        handler = logging.StreamHandler(sys.stdout)\n        handler.setLevel(logging.INFO)\n\n        # Create formatter\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n            datefmt=\"%Y-%m-%d %H:%M:%S\",\n        )\n        handler.setFormatter(formatter)\n\n        # Add handler to logger\n        logger.addHandler(handler)\n        logger.setLevel(logging.INFO)\n        logger.propagate = False\n\n    return logger\n</code></pre>"},{"location":"api/utils/#nettools.utils.logger.set_log_level","title":"<code>set_log_level(level)</code>","text":"<p>Set the global log level for nettools loggers.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>Log level ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')</p> required Source code in <code>nettools/utils/logger.py</code> <pre><code>def set_log_level(level: str) -&gt; None:\n    \"\"\"Set the global log level for nettools loggers.\n\n    Args:\n        level: Log level ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')\n    \"\"\"\n    numeric_level = getattr(logging, level.upper(), None)\n    if not isinstance(numeric_level, int):\n        raise ValueError(f\"Invalid log level: {level}\")\n\n    logger = get_logger()\n    logger.setLevel(numeric_level)\n    for handler in logger.handlers:\n        handler.setLevel(numeric_level)\n</code></pre>"},{"location":"api/utils/#platform-detection","title":"Platform Detection","text":""},{"location":"api/utils/#nettools.utils.platform_detect","title":"<code>nettools.utils.platform_detect</code>","text":"<p>Platform detection utilities.</p>"},{"location":"api/utils/#nettools.utils.platform_detect.PlatformType","title":"<code>PlatformType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported platforms.</p> Source code in <code>nettools/utils/platform_detect.py</code> <pre><code>class PlatformType(Enum):\n    \"\"\"Enumeration of supported platforms.\"\"\"\n\n    LINUX = \"linux\"\n    MACOS = \"macos\"\n    WINDOWS = \"windows\"\n    UNKNOWN = \"unknown\"\n</code></pre>"},{"location":"api/utils/#nettools.utils.platform_detect.get_platform","title":"<code>get_platform()</code>","text":"<p>Detect the current platform.</p> <p>Returns:</p> Type Description <code>PlatformType</code> <p>PlatformType enum value representing the current platform.</p> Source code in <code>nettools/utils/platform_detect.py</code> <pre><code>def get_platform() -&gt; PlatformType:\n    \"\"\"Detect the current platform.\n\n    Returns:\n        PlatformType enum value representing the current platform.\n    \"\"\"\n    system = platform.system().lower()\n\n    if system == \"linux\":\n        return PlatformType.LINUX\n    elif system == \"darwin\":\n        return PlatformType.MACOS\n    elif system == \"windows\":\n        return PlatformType.WINDOWS\n    else:\n        return PlatformType.UNKNOWN\n</code></pre>"},{"location":"api/utils/#nettools.utils.platform_detect.get_platform_info","title":"<code>get_platform_info()</code>","text":"<p>Get detailed platform information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing platform details.</p> Source code in <code>nettools/utils/platform_detect.py</code> <pre><code>def get_platform_info() -&gt; dict:\n    \"\"\"Get detailed platform information.\n\n    Returns:\n        Dictionary containing platform details.\n    \"\"\"\n    return {\n        \"system\": platform.system(),\n        \"platform\": get_platform().value,\n        \"release\": platform.release(),\n        \"version\": platform.version(),\n        \"machine\": platform.machine(),\n        \"processor\": platform.processor(),\n        \"architecture\": platform.architecture()[0],\n        \"node\": platform.node(),\n    }\n</code></pre>"},{"location":"api/utils/#nettools.utils.platform_detect.get_shell_command_prefix","title":"<code>get_shell_command_prefix()</code>","text":"<p>Get the appropriate shell command prefix for the platform.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>Tuple of command prefix parts.</p> Source code in <code>nettools/utils/platform_detect.py</code> <pre><code>def get_shell_command_prefix() -&gt; tuple[str, ...]:\n    \"\"\"Get the appropriate shell command prefix for the platform.\n\n    Returns:\n        Tuple of command prefix parts.\n    \"\"\"\n    if is_windows():\n        return (\"cmd\", \"/c\")\n    else:\n        return (\"sh\", \"-c\")\n</code></pre>"},{"location":"api/utils/#nettools.utils.platform_detect.is_linux","title":"<code>is_linux()</code>","text":"<p>Check if running on Linux.</p> Source code in <code>nettools/utils/platform_detect.py</code> <pre><code>def is_linux() -&gt; bool:\n    \"\"\"Check if running on Linux.\"\"\"\n    return get_platform() == PlatformType.LINUX\n</code></pre>"},{"location":"api/utils/#nettools.utils.platform_detect.is_macos","title":"<code>is_macos()</code>","text":"<p>Check if running on macOS.</p> Source code in <code>nettools/utils/platform_detect.py</code> <pre><code>def is_macos() -&gt; bool:\n    \"\"\"Check if running on macOS.\"\"\"\n    return get_platform() == PlatformType.MACOS\n</code></pre>"},{"location":"api/utils/#nettools.utils.platform_detect.is_windows","title":"<code>is_windows()</code>","text":"<p>Check if running on Windows.</p> Source code in <code>nettools/utils/platform_detect.py</code> <pre><code>def is_windows() -&gt; bool:\n    \"\"\"Check if running on Windows.\"\"\"\n    return get_platform() == PlatformType.WINDOWS\n</code></pre>"},{"location":"development/architecture/","title":"Architecture","text":""},{"location":"development/architecture/#overview","title":"Overview","text":"<p>NetTools is a cross-platform CLI automation suite designed with modularity and extensibility in mind. The architecture is organized into several key components:</p>"},{"location":"development/architecture/#component-structure","title":"Component Structure","text":""},{"location":"development/architecture/#cli-layer-nettoolscli","title":"CLI Layer (<code>nettools.cli</code>)","text":"<ul> <li>Purpose: Command-line interface and user interaction</li> <li>Key Components: </li> <li><code>main.py</code>: Main CLI application using Typer</li> <li>Command handlers for each tool functionality</li> </ul>"},{"location":"development/architecture/#core-layer-nettoolscore","title":"Core Layer (<code>nettools.core</code>)","text":"<ul> <li>Purpose: Core business logic and tool implementations</li> <li>Key Components:</li> <li><code>ping.py</code>: Network connectivity testing</li> <li><code>ports.py</code>: Port scanning and checking</li> <li><code>sysinfo.py</code>: System information gathering</li> <li><code>iperf3.py</code>: Network performance testing</li> </ul>"},{"location":"development/architecture/#utilities-layer-nettoolsutils","title":"Utilities Layer (<code>nettools.utils</code>)","text":"<ul> <li>Purpose: Cross-cutting concerns and shared functionality</li> <li>Key Components:</li> <li><code>logger.py</code>: Centralized logging</li> <li><code>platform_detect.py</code>: Cross-platform compatibility handling</li> </ul>"},{"location":"development/architecture/#design-principles","title":"Design Principles","text":"<ol> <li>Cross-Platform Compatibility: All core functionality works across Windows, macOS, and Linux</li> <li>Modular Design: Each tool is implemented as a separate module</li> <li>Rich Output: Support for both human-readable and JSON output formats</li> <li>Error Handling: Comprehensive error handling with meaningful messages</li> <li>Testability: Designed with testing in mind, using dependency injection where appropriate</li> </ol>"},{"location":"development/architecture/#data-flow","title":"Data Flow","text":"<ol> <li>User invokes CLI command</li> <li>CLI layer validates input and routes to appropriate core module</li> <li>Core module executes the requested functionality</li> <li>Results are formatted and returned to CLI layer</li> <li>CLI layer outputs results in requested format (text or JSON)</li> </ol>"},{"location":"development/contributing/","title":"Contributing Guide","text":"<p>We welcome contributions to NetTools! This guide will help you get started.</p>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Git</li> <li>Optional: iperf3 for testing bandwidth functionality</li> </ul>"},{"location":"development/contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li> <p>Fork and Clone <pre><code>git clone https://github.com/YOUR_USERNAME/cross-platform-automation-tools.git\ncd cross-platform-automation-tools\n</code></pre></p> </li> <li> <p>Create Virtual Environment <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install Development Dependencies <pre><code>pip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Install Pre-commit Hooks (Optional) <pre><code>pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#code-style-and-quality","title":"Code Style and Quality","text":"<p>We use several tools to maintain code quality:</p> <ul> <li>Black: Code formatting</li> <li>isort: Import sorting</li> <li>ruff: Linting and code analysis</li> <li>mypy: Static type checking</li> </ul> <p>Run all checks: <pre><code># Format code\nblack src tests\nisort src tests\n\n# Lint code\nruff check src tests\n\n# Type checking\nmypy src\n</code></pre></p>"},{"location":"development/contributing/#testing","title":"Testing","text":"<p>We use pytest for testing with comprehensive coverage:</p> <pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=nettools --cov-report=term-missing\n\n# Run specific test file\npytest tests/test_core/test_sysinfo.py\n\n# Run with verbose output\npytest -v\n</code></pre>"},{"location":"development/contributing/#adding-new-features","title":"Adding New Features","text":"<ol> <li> <p>Create Feature Branch <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Write Tests First (TDD)</p> </li> <li>Add tests in appropriate <code>tests/</code> subdirectory</li> <li>Ensure tests fail initially</li> <li> <p>Implement feature to make tests pass</p> </li> <li> <p>Implementation Guidelines</p> </li> <li>Follow existing code patterns</li> <li>Add type hints to all functions</li> <li>Include comprehensive docstrings</li> <li> <p>Handle cross-platform differences</p> </li> <li> <p>Documentation</p> </li> <li>Update relevant documentation</li> <li>Add usage examples if applicable</li> <li>Update CLI help text</li> </ol>"},{"location":"development/contributing/#code-standards","title":"Code Standards","text":""},{"location":"development/contributing/#python-style","title":"Python Style","text":"<ul> <li>PEP 8 compliance (enforced by black and ruff)</li> <li>Type hints for all function parameters and return values</li> <li>Docstrings for all public functions (Google style)</li> <li>Error handling with appropriate exceptions</li> </ul>"},{"location":"development/contributing/#example-function-template","title":"Example Function Template","text":"<pre><code>def example_function(param: str, optional_param: int | None = None) -&gt; dict:\n    \"\"\"Brief description of the function.\n\n    Args:\n        param: Description of the parameter.\n        optional_param: Description of optional parameter.\n\n    Returns:\n        Dictionary containing the result.\n\n    Raises:\n        ValueError: When param is invalid.\n        RuntimeError: When operation fails.\n    \"\"\"\n    if not param:\n        raise ValueError(\"param cannot be empty\")\n\n    try:\n        # Implementation here\n        result = {\"success\": True, \"data\": param}\n        return result\n    except Exception as e:\n        raise RuntimeError(f\"Operation failed: {e}\")\n</code></pre>"},{"location":"development/contributing/#testing-standards","title":"Testing Standards","text":"<ul> <li>Unit tests for all public functions</li> <li>Integration tests for CLI commands</li> <li>Mock external dependencies (subprocess, network calls)</li> <li>Cross-platform test coverage</li> <li>Minimum 80% code coverage for new features</li> </ul>"},{"location":"development/contributing/#example-test-template","title":"Example Test Template","text":"<pre><code>\"\"\"Tests for example module.\"\"\"\n\nfrom unittest.mock import Mock, patch\n\nimport pytest\n\nfrom nettools.core.example import ExampleClass\n\n\nclass TestExampleClass:\n    \"\"\"Test cases for ExampleClass.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.example = ExampleClass()\n\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality works correctly.\"\"\"\n        result = self.example.basic_method(\"test\")\n        assert result == \"expected_output\"\n\n    @patch(\"external.dependency\")\n    def test_with_mock(self, mock_dependency):\n        \"\"\"Test functionality with mocked dependencies.\"\"\"\n        mock_dependency.return_value = \"mocked_value\"\n\n        result = self.example.method_with_dependency()\n\n        assert result == \"expected_result\"\n        mock_dependency.assert_called_once()\n\n    def test_error_handling(self):\n        \"\"\"Test error handling.\"\"\"\n        with pytest.raises(ValueError, match=\"specific error message\"):\n            self.example.method_that_should_fail(\"invalid_input\")\n</code></pre>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"development/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li> <p>Run all quality checks <pre><code>black src tests\nisort src tests\nruff check src tests\nmypy src\npytest --cov=nettools\n</code></pre></p> </li> <li> <p>Ensure tests pass on your platform</p> </li> <li>Update documentation if needed</li> <li>Add changelog entry if applicable</li> </ol>"},{"location":"development/contributing/#pr-requirements","title":"PR Requirements","text":"<ul> <li>Clear description of changes</li> <li>Reference issue number if applicable</li> <li>All tests passing in CI</li> <li>Code coverage maintained or improved</li> <li>Documentation updated if needed</li> </ul>"},{"location":"development/contributing/#pr-template","title":"PR Template","text":"<pre><code>## Description\nBrief description of changes made.\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Documentation update\n- [ ] Performance improvement\n- [ ] Refactoring\n\n## Testing\n- [ ] Unit tests added/updated\n- [ ] Integration tests pass\n- [ ] Manual testing performed\n\n## Checklist\n- [ ] Code follows style guidelines\n- [ ] Tests added for new functionality\n- [ ] Documentation updated\n- [ ] CI checks pass\n</code></pre>"},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<pre><code>cross-platform-automation-tools/\n\u251c\u2500\u2500 src/nettools/           # Main package\n\u2502   \u251c\u2500\u2500 cli/               # CLI interface\n\u2502   \u251c\u2500\u2500 core/              # Core functionality\n\u2502   \u2514\u2500\u2500 utils/             # Utility modules\n\u251c\u2500\u2500 tests/                 # Test suite\n\u2502   \u251c\u2500\u2500 test_cli.py       # CLI tests\n\u2502   \u251c\u2500\u2500 test_core/        # Core module tests\n\u2502   \u2514\u2500\u2500 test_utils/       # Utility tests\n\u251c\u2500\u2500 docs/                  # Documentation\n\u251c\u2500\u2500 .github/workflows/     # CI/CD configuration\n\u2514\u2500\u2500 pyproject.toml        # Project configuration\n</code></pre>"},{"location":"development/contributing/#adding-new-commands","title":"Adding New Commands","text":"<p>To add a new CLI command:</p> <ol> <li>Create core functionality in <code>src/nettools/core/</code></li> <li>Add CLI interface in <code>src/nettools/cli/main.py</code></li> <li>Write comprehensive tests</li> <li>Update documentation</li> <li>Add usage examples</li> </ol>"},{"location":"development/contributing/#example-adding-a-new-command","title":"Example: Adding a New Command","text":"<pre><code># In src/nettools/core/new_feature.py\nclass NewFeature:\n    \"\"\"Implementation of new feature.\"\"\"\n\n    def execute(self, param: str) -&gt; dict:\n        \"\"\"Execute the new feature.\"\"\"\n        # Implementation here\n        return {\"result\": \"success\"}\n\n# In src/nettools/cli/main.py\n@app.command(\"new-command\")\ndef new_command(\n    param: str = typer.Argument(..., help=\"Required parameter\"),\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output in JSON format\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n) -&gt; None:\n    \"\"\"Description of the new command.\"\"\"\n    if verbose:\n        logger.setLevel(\"DEBUG\")\n\n    feature = NewFeature()\n\n    try:\n        result = feature.execute(param)\n\n        if json_output:\n            console.print(json.dumps(result, indent=2))\n        else:\n            # Display formatted output\n            console.print(f\"Result: {result}\")\n\n    except Exception as e:\n        logger.error(f\"Command error: {e}\")\n        console.print(f\"[red]Error: {e}[/red]\")\n        raise typer.Exit(1)\n</code></pre>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<p>Releases are managed by maintainers:</p> <ol> <li>Version bump in <code>pyproject.toml</code></li> <li>Update changelog</li> <li>Create release tag</li> <li>Publish to PyPI</li> <li>Update documentation</li> </ol>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: Report bugs or request features</li> <li>Discussions: Ask questions or discuss ideas</li> <li>Documentation: Check existing docs first</li> <li>Code Review: Maintainers will review PRs</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and inclusive in all interactions. We want this to be a welcoming community for everyone.</p> <p>Thank you for contributing to NetTools! \ud83d\ude80</p>"},{"location":"development/testing/","title":"Testing","text":""},{"location":"development/testing/#overview","title":"Overview","text":"<p>NetTools uses a comprehensive testing strategy to ensure reliability across all supported platforms.</p>"},{"location":"development/testing/#testing-framework","title":"Testing Framework","text":"<p>The project uses pytest as the primary testing framework, with additional tools for coverage and mocking:</p> <ul> <li><code>pytest</code>: Core testing framework</li> <li><code>pytest-cov</code>: Coverage reporting</li> <li><code>pytest-mock</code>: Mocking capabilities</li> </ul>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<p>Tests are organized in the <code>tests/</code> directory with the following structure:</p> <pre><code>tests/\n\u251c\u2500\u2500 conftest.py          # Shared fixtures and configuration\n\u251c\u2500\u2500 test_cli.py          # CLI interface tests\n\u251c\u2500\u2500 test_core/           # Core module tests\n\u2502   \u251c\u2500\u2500 test_ping.py\n\u2502   \u251c\u2500\u2500 test_ports.py\n\u2502   \u251c\u2500\u2500 test_sysinfo.py\n\u2502   \u2514\u2500\u2500 test_iperf3.py\n\u2514\u2500\u2500 test_utils/          # Utility module tests\n    \u251c\u2500\u2500 test_logger.py\n    \u2514\u2500\u2500 test_platform_detect.py\n</code></pre>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#local-testing","title":"Local Testing","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=nettools --cov-report=term-missing\n\n# Run specific test file\npytest tests/test_cli.py\n\n# Run specific test\npytest tests/test_cli.py::test_main_help\n</code></pre>"},{"location":"development/testing/#cicd-testing","title":"CI/CD Testing","text":"<p>Tests are automatically run across multiple platforms and Python versions: - Platforms: Ubuntu, Windows, macOS - Python Versions: 3.10, 3.11, 3.12</p>"},{"location":"development/testing/#test-types","title":"Test Types","text":""},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":"<ul> <li>Test individual functions and methods in isolation</li> <li>Use mocking for external dependencies (network calls, system commands)</li> <li>Focus on edge cases and error conditions</li> </ul>"},{"location":"development/testing/#integration-tests","title":"Integration Tests","text":"<ul> <li>Test end-to-end CLI functionality</li> <li>Verify actual tool execution where possible</li> <li>Test JSON output formatting</li> </ul>"},{"location":"development/testing/#platform-specific-tests","title":"Platform-Specific Tests","text":"<ul> <li>Verify cross-platform compatibility</li> <li>Handle platform-specific differences in tool behavior</li> <li>Mock platform-specific functionality when needed</li> </ul>"},{"location":"development/testing/#mocking-strategy","title":"Mocking Strategy","text":"<p>External dependencies are mocked to ensure reliable, fast tests: - Network requests and responses - System command execution - File system operations - Platform-specific system calls</p>"},{"location":"development/testing/#coverage-goals","title":"Coverage Goals","text":"<ul> <li>Maintain minimum 80% code coverage</li> <li>Focus on critical paths and error handling</li> <li>Exclude trivial code from coverage requirements</li> </ul>"},{"location":"usage/cli/","title":"CLI Reference","text":"<p>NetTools provides a comprehensive command-line interface for network and system automation tasks.</p>"},{"location":"usage/cli/#global-options","title":"Global Options","text":"<p>All commands support these global options:</p> <ul> <li><code>--json</code>: Output results in JSON format</li> <li><code>--verbose</code>, <code>-v</code>: Enable verbose/debug output  </li> <li><code>--help</code>: Show command-specific help</li> </ul>"},{"location":"usage/cli/#commands","title":"Commands","text":""},{"location":"usage/cli/#nettools-iperf3-run","title":"<code>nettools iperf3-run</code>","text":"<p>Run iperf3 bandwidth tests in client or server mode.</p> <p>Usage: <pre><code># Server mode\nnettools iperf3-run --server [OPTIONS]\n\n# Client mode  \nnettools iperf3-run --client HOST [OPTIONS]\n</code></pre></p> <p>Options: - <code>--server</code>, <code>-s</code>: Run in server mode - <code>--client HOST</code>, <code>-c HOST</code>: Connect to server at address - <code>--port PORT</code>, <code>-p PORT</code>: Port to use (default: 5201) - <code>--duration SECONDS</code>, <code>-t SECONDS</code>: Test duration in seconds (default: 10)</p> <p>Examples: <pre><code># Start server\nnettools iperf3-run --server --port 5201\n\n# Run client test\nnettools iperf3-run --client 192.168.1.5 --duration 30 --json\n</code></pre></p>"},{"location":"usage/cli/#nettools-ping-host","title":"<code>nettools ping-host</code>","text":"<p>Ping a host and show connectivity results.</p> <p>Usage: <pre><code>nettools ping-host HOST [OPTIONS]\n</code></pre></p> <p>Options: - <code>--count COUNT</code>, <code>-c COUNT</code>: Number of pings (default: 4) - <code>--timeout SECONDS</code>, <code>-t SECONDS</code>: Timeout in seconds (default: 5)</p> <p>Examples: <pre><code># Basic ping\nnettools ping-host google.com\n\n# Ping with custom count and JSON output\nnettools ping-host 8.8.8.8 --count 10 --json\n</code></pre></p>"},{"location":"usage/cli/#nettools-check-ports","title":"<code>nettools check-ports</code>","text":"<p>Check if ports are open on a host.</p> <p>Usage: <pre><code>nettools check-ports PORTS [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>PORTS</code>: Comma-separated list of ports (e.g., \"80,443,8080\")</p> <p>Options: - <code>--host HOST</code>, <code>-h HOST</code>: Host to check (default: localhost) - <code>--timeout SECONDS</code>, <code>-t SECONDS</code>: Connection timeout (default: 5)</p> <p>Examples: <pre><code># Check local ports\nnettools check-ports 22,80,443\n\n# Check remote host with JSON output\nnettools check-ports 80,443,8080 --host example.com --json\n</code></pre></p>"},{"location":"usage/cli/#nettools-sysinfo","title":"<code>nettools sysinfo</code>","text":"<p>Display comprehensive system information.</p> <p>Usage: <pre><code>nettools sysinfo [OPTIONS]\n</code></pre></p> <p>Examples: <pre><code># Display system info\nnettools sysinfo\n\n# Get system info as JSON\nnettools sysinfo --json --verbose\n</code></pre></p>"},{"location":"usage/cli/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code>: Success</li> <li><code>1</code>: General error (network failure, invalid arguments, etc.)</li> <li><code>2</code>: Command line argument error</li> </ul>"},{"location":"usage/cli/#json-output-format","title":"JSON Output Format","text":"<p>When using <code>--json</code>, all commands output structured JSON data:</p> <pre><code>{\n  \"command\": \"ping-host\",\n  \"host\": \"example.com\",\n  \"result\": { ... },\n  \"timestamp\": \"2024-01-01T12:00:00\"\n}\n</code></pre>"},{"location":"usage/examples/","title":"Usage Examples","text":"<p>This page provides practical examples of using NetTools for common automation tasks.</p>"},{"location":"usage/examples/#network-performance-testing","title":"Network Performance Testing","text":""},{"location":"usage/examples/#basic-bandwidth-testing","title":"Basic Bandwidth Testing","text":"<pre><code># Start iperf3 server on default port\nnettools iperf3-run --server\n\n# Run bandwidth test from another machine\nnettools iperf3-run --client 192.168.1.100 --duration 30\n\n# Get results in JSON format for automation\nnettools iperf3-run --client 192.168.1.100 --duration 10 --json\n</code></pre>"},{"location":"usage/examples/#advanced-iperf3-usage","title":"Advanced iperf3 Usage","text":"<pre><code># Use custom port\nnettools iperf3-run --server --port 8080\n\n# Extended test duration with verbose output\nnettools iperf3-run --client server.example.com --duration 60 --verbose\n</code></pre>"},{"location":"usage/examples/#connectivity-testing","title":"Connectivity Testing","text":""},{"location":"usage/examples/#basic-ping-tests","title":"Basic Ping Tests","text":"<pre><code># Quick connectivity check\nnettools ping-host google.com\n\n# Extended ping test with more packets\nnettools ping-host 8.8.8.8 --count 20\n\n# Ping with timeout and JSON output\nnettools ping-host unreliable-host.com --timeout 10 --json\n</code></pre>"},{"location":"usage/examples/#port-connectivity","title":"Port Connectivity","text":"<pre><code># Check common web ports\nnettools check-ports 80,443 --host example.com\n\n# Check database ports on local machine\nnettools check-ports 3306,5432,27017 --host localhost\n\n# Quick service availability check\nnettools check-ports 22,80,443,8080 --host production-server.com --json\n</code></pre>"},{"location":"usage/examples/#system-monitoring","title":"System Monitoring","text":""},{"location":"usage/examples/#system-information","title":"System Information","text":"<pre><code># Get complete system overview\nnettools sysinfo\n\n# System info for monitoring scripts\nnettools sysinfo --json | jq '.memory.percent'\n\n# Verbose system diagnostics\nnettools sysinfo --verbose\n</code></pre>"},{"location":"usage/examples/#automation-scripts","title":"Automation Scripts","text":""},{"location":"usage/examples/#bash-script-example","title":"Bash Script Example","text":"<pre><code>#!/bin/bash\n# Network health check script\n\nHOSTS=(\"google.com\" \"github.com\" \"stackoverflow.com\")\nRESULTS_DIR=\"/tmp/nettools-results\"\n\nmkdir -p \"$RESULTS_DIR\"\n\necho \"Starting network health check...\"\n\nfor host in \"${HOSTS[@]}\"; do\n    echo \"Testing $host...\"\n\n    # Ping test\n    nettools ping-host \"$host\" --count 5 --json &gt; \"$RESULTS_DIR/ping-$host.json\"\n\n    # Port test\n    nettools check-ports 80,443 --host \"$host\" --json &gt; \"$RESULTS_DIR/ports-$host.json\"\ndone\n\n# System info\nnettools sysinfo --json &gt; \"$RESULTS_DIR/sysinfo.json\"\n\necho \"Health check complete. Results in $RESULTS_DIR\"\n</code></pre>"},{"location":"usage/examples/#python-script-example","title":"Python Script Example","text":"<pre><code>#!/usr/bin/env python3\nimport json\nimport subprocess\nimport sys\n\ndef run_nettools_command(cmd):\n    \"\"\"Run nettools command and return JSON result.\"\"\"\n    try:\n        result = subprocess.run(\n            [\"nettools\"] + cmd + [\"--json\"],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n        return json.loads(result.stdout)\n    except subprocess.CalledProcessError as e:\n        print(f\"Command failed: {e}\")\n        return None\n    except json.JSONDecodeError as e:\n        print(f\"Failed to parse JSON: {e}\")\n        return None\n\ndef main():\n    \"\"\"Network monitoring example.\"\"\"\n\n    # Check system health\n    print(\"Checking system health...\")\n    sysinfo = run_nettools_command([\"sysinfo\"])\n    if sysinfo:\n        memory_usage = sysinfo[\"memory\"][\"percent\"]\n        print(f\"Memory usage: {memory_usage}%\")\n\n        if memory_usage &gt; 80:\n            print(\"WARNING: High memory usage detected!\")\n\n    # Check critical services\n    print(\"Checking critical services...\")\n    services = [\n        (\"localhost\", \"22,80,443\"),\n        (\"8.8.8.8\", \"53\"),  # DNS\n        (\"google.com\", \"80,443\")\n    ]\n\n    for host, ports in services:\n        result = run_nettools_command([\"check-ports\", ports, \"--host\", host])\n        if result:\n            open_ports = result[\"summary\"][\"open\"]\n            closed_ports = result[\"summary\"][\"closed\"]\n            print(f\"{host}: {len(open_ports)} open, {len(closed_ports)} closed\")\n\n            if closed_ports:\n                print(f\"  WARNING: Closed ports: {closed_ports}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"usage/examples/#powershell-script-example","title":"PowerShell Script Example","text":"<pre><code># NetTools PowerShell automation example\nparam(\n    [string]$TargetHost = \"example.com\",\n    [string]$OutputDir = \"C:\\temp\\nettools-results\"\n)\n\n# Create output directory\nNew-Item -ItemType Directory -Path $OutputDir -Force | Out-Null\n\nWrite-Host \"Starting network analysis for $TargetHost...\"\n\n# System information\nWrite-Host \"Gathering system information...\"\nnettools sysinfo --json | Out-File -FilePath \"$OutputDir\\sysinfo.json\"\n\n# Connectivity test\nWrite-Host \"Testing connectivity to $TargetHost...\"\nnettools ping-host $TargetHost --count 10 --json | Out-File -FilePath \"$OutputDir\\ping-$TargetHost.json\"\n\n# Port scan\nWrite-Host \"Scanning common ports on $TargetHost...\"\nnettools check-ports \"21,22,23,25,53,80,110,143,443,993,995\" --host $TargetHost --json | Out-File -FilePath \"$OutputDir\\ports-$TargetHost.json\"\n\n# Parse results\n$pingResult = Get-Content \"$OutputDir\\ping-$TargetHost.json\" | ConvertFrom-Json\n$portResult = Get-Content \"$OutputDir\\ports-$TargetHost.json\" | ConvertFrom-Json\n\nWrite-Host \"Results:\"\nWrite-Host \"  Ping packet loss: $($pingResult.packet_loss)%\"\nWrite-Host \"  Open ports: $($portResult.summary.open -join ', ')\"\nWrite-Host \"  Closed ports: $($portResult.summary.closed -join ', ')\"\n\nWrite-Host \"Analysis complete. Results saved to $OutputDir\"\n</code></pre>"},{"location":"usage/examples/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"usage/examples/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Network Health Check\n\non:\n  schedule:\n    - cron: '0 */6 * * *'  # Every 6 hours\n  workflow_dispatch:\n\njobs:\n  health-check:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Install NetTools\n      run: pip install nettools\n\n    - name: Check system health\n      run: |\n        nettools sysinfo --json &gt; sysinfo.json\n        nettools ping-host google.com --count 5 --json &gt; ping-google.json\n        nettools check-ports 80,443 --host github.com --json &gt; ports-github.json\n\n    - name: Upload results\n      uses: actions/upload-artifact@v3\n      with:\n        name: health-check-results\n        path: \"*.json\"\n</code></pre>"},{"location":"usage/examples/#docker-health-check","title":"Docker Health Check","text":"<pre><code>FROM python:3.11-slim\n\nRUN pip install nettools\n\n# Health check script\nCOPY health-check.sh /usr/local/bin/\nRUN chmod +x /usr/local/bin/health-check.sh\n\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD /usr/local/bin/health-check.sh\n</code></pre> <pre><code>#!/bin/bash\n# health-check.sh\n\n# Check if critical services are responding\nnettools check-ports 80,443 --host localhost --timeout 5 &gt; /dev/null\nEXIT_CODE=$?\n\nif [ $EXIT_CODE -eq 0 ]; then\n    echo \"Health check passed\"\n    exit 0\nelse\n    echo \"Health check failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"usage/examples/#monitoring-and-alerting","title":"Monitoring and Alerting","text":""},{"location":"usage/examples/#simple-monitoring-loop","title":"Simple Monitoring Loop","text":"<pre><code>#!/bin/bash\n# continuous-monitor.sh\n\nINTERVAL=60  # seconds\nLOG_FILE=\"/var/log/nettools-monitor.log\"\n\nwhile true; do\n    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')\n\n    # Get system metrics\n    MEMORY_USAGE=$(nettools sysinfo --json | jq -r '.memory.percent')\n\n    # Check connectivity\n    PING_RESULT=$(nettools ping-host 8.8.8.8 --count 1 --json | jq -r '.packet_loss')\n\n    echo \"$TIMESTAMP - Memory: ${MEMORY_USAGE}%, Ping Loss: ${PING_RESULT}%\" &gt;&gt; \"$LOG_FILE\"\n\n    # Alert on high memory usage\n    if (( $(echo \"$MEMORY_USAGE &gt; 85\" | bc -l) )); then\n        echo \"ALERT: High memory usage: ${MEMORY_USAGE}%\" &gt;&gt; \"$LOG_FILE\"\n        # Send notification (mail, webhook, etc.)\n    fi\n\n    sleep $INTERVAL\ndone\n</code></pre> <p>These examples demonstrate the versatility of NetTools for automation, monitoring, and integration into existing workflows.</p>"}]}